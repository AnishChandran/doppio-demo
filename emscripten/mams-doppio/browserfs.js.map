{"version":3,"file":"browserfs.js","sources":["../vendor/almond/almond.js","core/string_util.js","core/buffer_common.js","core/buffer_old.js","core/api_error.js","core/buffer_modern.js","core/buffer.js","core/file_flag.js","core/node_process.js","core/node_path.js","core/node_fs.js","generic/preload_file.js","core/browserfs.js","core/file.js","core/file_system.js","core/node_fs_stats.js","backend/../../vendor/async/lib/async.js","backend/dropbox.js","backend/html5fs.js","generic/file_index.js","generic/indexed_filesystem.js","core/util.js","backend/in_memory.js","backend/localStorage.js","backend/mountable_file_system.js","generic/xhr.js","backend/XmlHttpRequest.js"],"names":[],"mappings":"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","sourcesContent":["\n/**\n * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"../vendor/almond/almond\", function(){});\n","\ndefine('core/string_util',[\"require\", \"exports\"], function(require, exports) {\n    \n\n    /**\n    * Find the 'utility' object for the given string encoding. Throws an exception\n    * if the encoding is invalid.\n    * @param [String] encoding a string encoding\n    * @return [BrowserFS.StringUtil.*] The StringUtil object for the given encoding\n    */\n    function FindUtil(encoding) {\n        encoding = (function () {\n            switch (typeof encoding) {\n                case 'object':\n                    return \"\" + encoding;\n                case 'string':\n                    return encoding;\n                default:\n                    throw new Error('Invalid encoding argument specified');\n            }\n        })();\n        encoding = encoding.toLowerCase();\n\n        switch (encoding) {\n            case 'utf8':\n            case 'utf-8':\n                return UTF8;\n            case 'ascii':\n            case 'binary':\n                // @todo How is binary different from ascii?\n                return ASCII;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return UCS2;\n            case 'hex':\n                return HEX;\n            case 'base64':\n                return BASE64;\n\n            case 'binary_string':\n                return BINSTR;\n            case 'binary_string_ie':\n                return BINSTRIE;\n\n            default:\n                throw new Error(\"Unknown encoding: \" + encoding);\n        }\n    }\n    exports.FindUtil = FindUtil;\n\n    /**\n    * String utility functions for UTF-8. Note that some UTF-8 strings *cannot* be\n    * expressed in terms of JavaScript UTF-16 strings.\n    * @see http://en.wikipedia.org/wiki/UTF-8\n    */\n    var UTF8 = (function () {\n        function UTF8() {\n        }\n        UTF8.str2byte = function (buf, str, offset, length) {\n            var i = 0;\n            var j = offset;\n            var maxJ = offset + length;\n            var rv = [];\n            var numChars = 0;\n            while (i < str.length && j < maxJ) {\n                var code = str.charCodeAt(i++);\n                var next = str.charCodeAt(i);\n                if (0xD800 <= code && code <= 0xDBFF && 0xDC00 <= next && next <= 0xDFFF) {\n                    if (j + 3 >= maxJ) {\n                        break;\n                    } else {\n                        numChars++;\n                    }\n\n                    // First pair: 10 bits of data, with an implicitly set 11th bit\n                    // Second pair: 10 bits of data\n                    var codePoint = (((code & 0x3FF) | 0x400) << 10) | (next & 0x3FF);\n\n                    // Highest 3 bits in first byte\n                    buf.writeUInt8((codePoint >> 18) | 0xF0, j++);\n\n                    // Rest are all 6 bits\n                    buf.writeUInt8(((codePoint >> 12) & 0x3F) | 0x80, j++);\n                    buf.writeUInt8(((codePoint >> 6) & 0x3F) | 0x80, j++);\n                    buf.writeUInt8((codePoint & 0x3F) | 0x80, j++);\n                    i++;\n                } else if (code < 0x80) {\n                    // One byte\n                    buf.writeUInt8(code, j++);\n                    numChars++;\n                } else if (code < 0x800) {\n                    if (j + 1 >= maxJ) {\n                        break;\n                    } else {\n                        numChars++;\n                    }\n\n                    // Highest 5 bits in first byte\n                    buf.writeUInt8((code >> 6) | 0xC0, j++);\n\n                    // Lower 6 bits in second byte\n                    buf.writeUInt8((code & 0x3F) | 0x80, j++);\n                } else if (code < 0x10000) {\n                    if (j + 2 >= maxJ) {\n                        break;\n                    } else {\n                        numChars++;\n                    }\n\n                    // Highest 4 bits in first byte\n                    buf.writeUInt8((code >> 12) | 0xE0, j++);\n\n                    // Middle 6 bits in second byte\n                    buf.writeUInt8(((code >> 6) & 0x3F) | 0x80, j++);\n\n                    // Lowest 6 bits in third byte\n                    buf.writeUInt8((code & 0x3F) | 0x80, j++);\n                }\n            }\n            return j - offset;\n        };\n\n        UTF8.byte2str = function (byteArray) {\n            var chars = [];\n            var i = 0;\n            while (i < byteArray.length) {\n                var code = byteArray[i++];\n                if (code < 0x80) {\n                    chars.push(String.fromCharCode(code));\n                } else if (code < 0xC0) {\n                    throw new Error('Found incomplete part of character in string.');\n                } else if (code < 0xE0) {\n                    // 2 bytes: 5 and 6 bits\n                    chars.push(String.fromCharCode(((code & 0x1F) << 6) | (byteArray[i++] & 0x3F)));\n                } else if (code < 0xF0) {\n                    // 3 bytes: 4, 6, and 6 bits\n                    chars.push(String.fromCharCode(((code & 0xF) << 12) | ((byteArray[i++] & 0x3F) << 6) | (byteArray[i++] & 0x3F)));\n                } else if (code < 0xF8) {\n                    // 4 bytes: 3, 6, 6, 6 bits; surrogate pairs time!\n                    // First 11 bits; remove 11th bit as per UTF-16 standard\n                    var byte3 = byteArray[i + 2];\n                    chars.push(String.fromCharCode(((((code & 0x7) << 8) | ((byteArray[i++] & 0x3F) << 2) | ((byteArray[i++] & 0x3F) >> 4)) & 0x3FF) | 0xD800));\n\n                    // Final 10 bits\n                    chars.push(String.fromCharCode((((byte3 & 0xF) << 6) | (byteArray[i++] & 0x3F)) | 0xDC00));\n                } else {\n                    throw new Error('Unable to represent UTF-8 string as UTF-16 JavaScript string.');\n                }\n            }\n            return chars.join('');\n        };\n\n        UTF8.byteLength = function (str) {\n            // Matches only the 10.. bytes that are non-initial characters in a\n            // multi-byte sequence.\n            // @todo This may be slower than iterating through the string in some cases.\n            var m = encodeURIComponent(str).match(/%[89ABab]/g);\n            return str.length + (m ? m.length : 0);\n        };\n        return UTF8;\n    })();\n    exports.UTF8 = UTF8;\n\n    /**\n    * String utility functions for 8-bit ASCII. Like Node, we mask the high bits of\n    * characters in JavaScript UTF-16 strings.\n    * @see http://en.wikipedia.org/wiki/ASCII\n    */\n    var ASCII = (function () {\n        function ASCII() {\n        }\n        ASCII.str2byte = function (buf, str, offset, length) {\n            length = str.length > length ? length : str.length;\n            for (var i = 0; i < length; i++) {\n                buf.writeUInt8(str.charCodeAt(i) % 256, offset + i);\n            }\n            return length;\n        };\n\n        ASCII.byte2str = function (byteArray) {\n            var chars = new Array(byteArray.length);\n            for (var i = 0; i < byteArray.length; i++) {\n                chars[i] = String.fromCharCode(byteArray[i] & 0x7F);\n            }\n            return chars.join('');\n        };\n\n        ASCII.byteLength = function (str) {\n            return str.length;\n        };\n        return ASCII;\n    })();\n    exports.ASCII = ASCII;\n\n    /**\n    * Contains string utility functions for base-64 encoding.\n    *\n    * Adapted from the StackOverflow comment linked below.\n    * @see http://stackoverflow.com/questions/246801/how-can-you-encode-to-base64-using-javascript#246813\n    * @see http://en.wikipedia.org/wiki/Base64\n    * @todo Bake in support for btoa() and atob() if available.\n    */\n    var BASE64 = (function () {\n        function BASE64() {\n        }\n        BASE64.byte2str = function (byteArray) {\n            var output = '';\n            var i = 0;\n            while (i < byteArray.length) {\n                var chr1 = byteArray[i++];\n                var chr2 = byteArray[i++];\n                var chr3 = byteArray[i++];\n                var enc1 = chr1 >> 2;\n                var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n                var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n                var enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + BASE64.num2b64[enc1] + BASE64.num2b64[enc2] + BASE64.num2b64[enc3] + BASE64.num2b64[enc4];\n            }\n            return output;\n        };\n\n        BASE64.str2byte = function (buf, str, offset, length) {\n            var output = '';\n            var i = 0;\n            str = str.replace(/[^A-Za-z0-9\\+\\/\\=\\-\\_]/g, '');\n            var j = 0;\n            while (i < str.length) {\n                var enc1 = BASE64.b642num[str.charAt(i++)];\n                var enc2 = BASE64.b642num[str.charAt(i++)];\n                var enc3 = BASE64.b642num[str.charAt(i++)];\n                var enc4 = BASE64.b642num[str.charAt(i++)];\n                var chr1 = (enc1 << 2) | (enc2 >> 4);\n                var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n                var chr3 = ((enc3 & 3) << 6) | enc4;\n                buf.writeUInt8(chr1, offset + j++);\n                if (j === length) {\n                    break;\n                }\n                if (enc3 !== 64) {\n                    output += buf.writeUInt8(chr2, offset + j++);\n                }\n                if (j === length) {\n                    break;\n                }\n                if (enc4 !== 64) {\n                    output += buf.writeUInt8(chr3, offset + j++);\n                }\n                if (j === length) {\n                    break;\n                }\n            }\n            return j;\n        };\n\n        BASE64.byteLength = function (str) {\n            return Math.floor(((str.replace(/[^A-Za-z0-9\\+\\/\\-\\_]/g, '')).length * 6) / 8);\n        };\n        BASE64.b64chars = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', '='];\n        BASE64.num2b64 = (function () {\n            var obj = new Array(BASE64.b64chars.length);\n            for (var idx = 0; idx < BASE64.b64chars.length; idx++) {\n                var i = BASE64.b64chars[idx];\n                obj[idx] = i;\n            }\n            return obj;\n        })();\n\n        BASE64.b642num = (function () {\n            var obj = {};\n            for (var idx = 0; idx < BASE64.b64chars.length; idx++) {\n                var i = BASE64.b64chars[idx];\n                obj[i] = idx;\n            }\n            obj['-'] = 62;\n            obj['_'] = 63;\n            return obj;\n        })();\n        return BASE64;\n    })();\n    exports.BASE64 = BASE64;\n\n    /**\n    * String utility functions for the UCS-2 encoding. Note that our UCS-2 handling\n    * is identical to our UTF-16 handling.\n    *\n    * Note: UCS-2 handling is identical to UTF-16.\n    * @see http://en.wikipedia.org/wiki/UCS2\n    */\n    var UCS2 = (function () {\n        function UCS2() {\n        }\n        UCS2.str2byte = function (buf, str, offset, length) {\n            var len = str.length;\n\n            if (len * 2 > length) {\n                len = length % 2 === 1 ? (length - 1) / 2 : length / 2;\n            }\n            for (var i = 0; i < len; i++) {\n                buf.writeUInt16LE(str.charCodeAt(i), offset + i * 2);\n            }\n            return len * 2;\n        };\n\n        UCS2.byte2str = function (byteArray) {\n            if (byteArray.length % 2 !== 0) {\n                throw new Error('Invalid UCS2 byte array.');\n            }\n            var chars = new Array(byteArray.length / 2);\n            for (var i = 0; i < byteArray.length; i += 2) {\n                chars[i / 2] = String.fromCharCode(byteArray[i] | (byteArray[i + 1] << 8));\n            }\n            return chars.join('');\n        };\n\n        UCS2.byteLength = function (str) {\n            return str.length * 2;\n        };\n        return UCS2;\n    })();\n    exports.UCS2 = UCS2;\n\n    /**\n    * Contains string utility functions for hex encoding.\n    * @see http://en.wikipedia.org/wiki/Hexadecimal\n    */\n    var HEX = (function () {\n        function HEX() {\n        }\n        HEX.str2byte = function (buf, str, offset, length) {\n            if (str.length % 2 === 1) {\n                throw new Error('Invalid hex string');\n            }\n\n            // Each character is 1 byte encoded as two hex characters; so 1 byte becomes\n            // 2 bytes.\n            var numBytes = str.length / 2;\n            if (numBytes > length) {\n                numBytes = length;\n            }\n            for (var i = 0; i < numBytes; i++) {\n                var char1 = this.hex2num[str.charAt(2 * i)];\n                var char2 = this.hex2num[str.charAt(2 * i + 1)];\n                buf.writeUInt8((char1 << 4) | char2, offset + i);\n            }\n            return numBytes;\n        };\n\n        HEX.byte2str = function (byteArray) {\n            var len = byteArray.length;\n            var chars = new Array(len * 2);\n            var j = 0;\n            for (var i = 0; i < len; i++) {\n                var hex2 = byteArray[i] & 0xF;\n                var hex1 = byteArray[i] >> 4;\n                chars[j++] = this.num2hex[hex1];\n                chars[j++] = this.num2hex[hex2];\n            }\n            return chars.join('');\n        };\n\n        HEX.byteLength = function (str) {\n            return str.length / 2;\n        };\n        HEX.HEXCHARS = '0123456789abcdef';\n\n        HEX.num2hex = (function () {\n            var obj = new Array(HEX.HEXCHARS.length);\n            for (var idx = 0; idx < HEX.HEXCHARS.length; idx++) {\n                var i = HEX.HEXCHARS[idx];\n                obj[idx] = i;\n            }\n            return obj;\n        })();\n\n        HEX.hex2num = (function () {\n            var idx, i;\n            var obj = {};\n            for (idx = 0; idx < HEX.HEXCHARS.length; idx++) {\n                i = HEX.HEXCHARS[idx];\n                obj[i] = idx;\n            }\n            var capitals = 'ABCDEF';\n            for (idx = 0; idx < capitals.length; idx++) {\n                i = capitals[idx];\n                obj[i] = idx + 10;\n            }\n            return obj;\n        })();\n        return HEX;\n    })();\n    exports.HEX = HEX;\n\n    /**\n    * Contains string utility functions for binary string encoding. This is where we\n    * pack arbitrary binary data as a UTF-16 string.\n    *\n    * Each character in the string is two bytes. The first character in the string\n    * is special: The first byte specifies if the binary data is of odd byte length.\n    * If it is, then it is a 1 and the second byte is the first byte of data; if\n    * not, it is a 0 and the second byte is 0.\n    *\n    * Everything is little endian.\n    */\n    var BINSTR = (function () {\n        function BINSTR() {\n        }\n        BINSTR.str2byte = function (buf, str, offset, length) {\n            if (str.length === 0) {\n                return 0;\n            }\n            var numBytes = BINSTR.byteLength(str);\n            if (numBytes > length) {\n                numBytes = length;\n            }\n            var j = 0;\n            var startByte = offset;\n            var endByte = startByte + numBytes;\n\n            // Handle first character separately\n            var firstChar = str.charCodeAt(j++);\n            if (firstChar !== 0) {\n                buf.writeUInt8(firstChar & 0xFF, offset);\n                startByte = offset + 1;\n            }\n            for (var i = startByte; i < endByte; i += 2) {\n                var chr = str.charCodeAt(j++);\n                if (endByte - i === 1) {\n                    // Write first byte of character\n                    buf.writeUInt8(chr >> 8, i);\n                }\n                if (endByte - i >= 2) {\n                    // Write both bytes in character\n                    buf.writeUInt16BE(chr, i);\n                }\n            }\n            return numBytes;\n        };\n\n        BINSTR.byte2str = function (byteArray) {\n            var len = byteArray.length;\n\n            if (len === 0) {\n                return '';\n            }\n            var chars = new Array(Math.floor(len / 2) + 1);\n            var j = 0;\n            for (var i = 0; i < chars.length; i++) {\n                if (i === 0) {\n                    if (len % 2 === 1) {\n                        chars[i] = String.fromCharCode((1 << 8) | byteArray[j++]);\n                    } else {\n                        chars[i] = String.fromCharCode(0);\n                    }\n                } else {\n                    chars[i] = String.fromCharCode((byteArray[j++] << 8) | byteArray[j++]);\n                }\n            }\n            return chars.join('');\n        };\n\n        BINSTR.byteLength = function (str) {\n            if (str.length === 0) {\n                // Special case: Empty string.\n                return 0;\n            }\n            var firstChar = str.charCodeAt(0);\n            var bytelen = (str.length - 1) * 2;\n            if (firstChar !== 0) {\n                bytelen++;\n            }\n            return bytelen;\n        };\n        return BINSTR;\n    })();\n    exports.BINSTR = BINSTR;\n\n    /**\n    * IE/older FF version of binary string. One byte per character, offset by 0x20.\n    */\n    var BINSTRIE = (function () {\n        function BINSTRIE() {\n        }\n        BINSTRIE.str2byte = function (buf, str, offset, length) {\n            length = str.length > length ? length : str.length;\n            for (var i = 0; i < length; i++) {\n                buf.writeUInt8(str.charCodeAt(i) - 0x20, offset + i);\n            }\n            return length;\n        };\n\n        BINSTRIE.byte2str = function (byteArray) {\n            var chars = new Array(byteArray.length);\n            for (var i = 0; i < byteArray.length; i++) {\n                chars[i] = String.fromCharCode(byteArray[i] + 0x20);\n            }\n            return chars.join('');\n        };\n\n        BINSTRIE.byteLength = function (str) {\n            return str.length;\n        };\n        return BINSTRIE;\n    })();\n    exports.BINSTRIE = BINSTRIE;\n});\n//# sourceMappingURL=string_util.js.map\n;","\ndefine('core/buffer_common',[\"require\", \"exports\", './string_util'], function(require, exports, __string_util__) {\n    /// <reference path=\"../../vendor/DefinitelyTyped/node/node.d.ts\" />\n    var string_util = __string_util__;\n    \n\n    /**\n    * Defines all of the common methods for the Buffer interface.\n    * Defining this separately from the actual Buffer class allows us to have\n    * multiple buffer implementations that share common method implementations.\n    */\n    var BufferCommon = (function () {\n        function BufferCommon() {\n        }\n        BufferCommon.isEncoding = /**\n        * Checks if enc is a valid string encoding type.\n        * @param {string} enc - Name of a string encoding type.\n        * @return {boolean} Whether or not enc is a valid encoding type.\n        */\n        function (enc) {\n            try  {\n                string_util.FindUtil(enc);\n            } catch (e) {\n                return false;\n            }\n            return true;\n        };\n\n        BufferCommon.isBuffer = /**\n        * Tests if obj is a Buffer.\n        * @param {object} obj - An arbitrary object\n        * @return {boolean} True if this object is a Buffer.\n        */\n        function (obj) {\n            return obj instanceof Buffer;\n        };\n\n        BufferCommon.byteLength = /**\n        * Gives the actual byte length of a string. This is not the same as\n        * String.prototype.length since that returns the number of characters in a\n        * string.\n        * @param {string} str - The string to get the byte length of\n        * @param {string} [encoding=utf8] - Character encoding of the string\n        * @return {number} The number of bytes in the string\n        */\n        function (str, encoding) {\n            if (typeof encoding === \"undefined\") { encoding = 'utf8'; }\n            var strUtil = string_util.FindUtil(encoding);\n            return strUtil.byteLength(str);\n        };\n\n        BufferCommon.concat = /**\n        * Returns a buffer which is the result of concatenating all the buffers in the\n        * list together.\n        * If the list has no items, or if the totalLength is 0, then it returns a\n        * zero-length buffer.\n        * If the list has exactly one item, then the first item of the list is\n        * returned.\n        * If the list has more than one item, then a new Buffer is created.\n        * If totalLength is not provided, it is read from the buffers in the list.\n        * However, this adds an additional loop to the function, so it is faster to\n        * provide the length explicitly.\n        * @param {Buffer[]} list - List of Buffer objects to concat\n        * @param {number} [totalLength] - Total length of the buffers when concatenated\n        * @return {Buffer}\n        */\n        function (list, totalLength) {\n            var item;\n            if (list.length === 0 || totalLength === 0) {\n                return new Buffer(0);\n            } else if (list.length === 1) {\n                return list[0];\n            } else {\n                if (totalLength == null) {\n                    // Calculate totalLength\n                    totalLength = 0;\n                    for (var i = 0; i < list.length; i++) {\n                        item = list[i];\n                        totalLength += item.length;\n                    }\n                }\n                var buf = new Buffer(totalLength);\n                var curPos = 0;\n                for (var j = 0; j < list.length; j++) {\n                    item = list[j];\n                    curPos += item.copy(buf, curPos);\n                }\n                return buf;\n            }\n        };\n\n        /**\n        * **NONSTANDARD**: Set the octet at index. The values refer to individual\n        * bytes, so the legal range is between 0x00 and 0xFF hex or 0 and 255.\n        * @param {number} index - the index to set the value at\n        * @param {number} value - the value to set at the given index\n        */\n        BufferCommon.prototype.set = function (index, value) {\n            return (this).writeUInt8(value, index);\n        };\n\n        /**\n        * **NONSTANDARD**: Get the octet at index.\n        * @param {number} index - index to fetch the value at\n        * @return {number} the value at the given index\n        */\n        BufferCommon.prototype.get = function (index) {\n            return (this).readUInt8(index);\n        };\n\n        /**\n        * Writes string to the buffer at offset using the given encoding.\n        * If buffer did not contain enough space to fit the entire string, it will\n        * write a partial amount of the string.\n        * @param {string} str - Data to be written to buffer\n        * @param {number} [offset=0] - Offset in the buffer to write to\n        * @param {number} [length=this.length] - Number of bytes to write\n        * @param {string} [encoding=utf8] - Character encoding\n        * @return {number} Number of octets written.\n        */\n        BufferCommon.prototype.write = function (str, offset, length, encoding) {\n            if (typeof offset === \"undefined\") { offset = 0; }\n            if (typeof length === \"undefined\") { length = (this).length; }\n            if (typeof encoding === \"undefined\") { encoding = 'utf8'; }\n            var _this = this;\n\n            if (typeof offset === 'string') {\n                // 'str' and 'encoding' specified\n                encoding = \"\" + offset;\n                offset = 0;\n                length = _this.length;\n            } else if (typeof length === 'string') {\n                // 'str', 'offset', and 'encoding' specified\n                encoding = \"\" + length;\n                length = _this.length;\n            }\n\n            if (offset >= _this.length) {\n                return 0;\n            }\n            var strUtil = string_util.FindUtil(encoding);\n\n            // Are we trying to write past the buffer?\n            length = length + offset > _this.length ? _this.length - offset : length;\n            return strUtil.str2byte(_this, str, offset, length);\n        };\n\n        /**\n        * Decodes a portion of the Buffer into a String.\n        * @param {string} encoding - Character encoding to decode to\n        * @param {number} [start=0] - Start position in the buffer\n        * @param {number} [end=this.length] - Ending position in the buffer\n        * @return {string} A string from buffer data encoded with encoding, beginning\n        *   at start, and ending at end.\n        */\n        BufferCommon.prototype.toString = function (encoding, start, end) {\n            if (typeof encoding === \"undefined\") { encoding = 'utf8'; }\n            if (typeof start === \"undefined\") { start = 0; }\n            if (typeof end === \"undefined\") { end = (this).length; }\n            var _this = this;\n            if (!(start <= end)) {\n                throw new Error(\"Invalid start/end positions: \" + start + \" - \" + end);\n            }\n            if (start === end) {\n                return '';\n            }\n            if (end > _this.length) {\n                end = _this.length;\n            }\n            var strUtil = string_util.FindUtil(encoding);\n\n            // Create a byte array of the needed characters.\n            var byteArr = _this._getByteArray(start, end);\n            return strUtil.byte2str(byteArr);\n        };\n\n        /**\n        * Returns a JSON-representation of the Buffer instance, which is identical to\n        * the output for JSON Arrays. JSON.stringify implicitly calls this function\n        * when stringifying a Buffer instance.\n        * @return {object} An object that can be used for JSON stringification.\n        */\n        BufferCommon.prototype.toJSON = function () {\n            return {\n                type: 'Buffer',\n                data: (this)._getByteArray(0, (this).length)\n            };\n        };\n\n        /**\n        * Does copy between buffers. The source and target regions can be overlapped.\n        * All values passed that are undefined/NaN or are out of bounds are set equal\n        * to their respective defaults.\n        * @param {Buffer} target - Buffer to copy into\n        * @param {number} [targetStart=0] - Index to start copying to in the targetBuffer\n        * @param {number} [sourceStart=0] - Index in this buffer to start copying from\n        * @param {number} [sourceEnd=this.length] - Index in this buffer stop copying at\n        * @return {number} The number of bytes copied into the target buffer.\n        */\n        BufferCommon.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {\n            if (typeof targetStart === \"undefined\") { targetStart = 0; }\n            if (typeof sourceStart === \"undefined\") { sourceStart = 0; }\n            if (typeof sourceEnd === \"undefined\") { sourceEnd = (this).length; }\n            var _this = this;\n\n            // The Node code is weird. It sets some out-of-bounds args to their defaults\n            // and throws exceptions for others (sourceEnd).\n            targetStart = targetStart < 0 ? 0 : targetStart;\n            sourceStart = sourceStart < 0 ? 0 : sourceStart;\n\n            if (sourceEnd < sourceStart) {\n                throw new RangeError('sourceEnd < sourceStart');\n            }\n            if (sourceEnd === sourceStart) {\n                return 0;\n            }\n            if (targetStart >= target.length) {\n                throw new RangeError('targetStart out of bounds');\n            }\n            if (sourceStart >= _this.length) {\n                throw new RangeError('sourceStart out of bounds');\n            }\n            if (sourceEnd > _this.length) {\n                throw new RangeError('sourceEnd out of bounds');\n            }\n            var bytesCopied = Math.min(sourceEnd - sourceStart, target.length - targetStart, _this.length - sourceStart);\n            for (var i = 0; i < bytesCopied; i++) {\n                target.writeUInt8(_this.readUInt8(sourceStart + i), targetStart + i);\n            }\n            return bytesCopied;\n        };\n\n        /**\n        * Returns a slice of this buffer.\n        * @param {number} [start=0] - Index to start slicing from\n        * @param {number} [end=this.length] - Index to stop slicing at\n        * @return {Buffer} A new buffer which references the same\n        *   memory as the old, but offset and cropped by the start (defaults to 0) and\n        *   end (defaults to buffer.length) indexes. Negative indexes start from the end\n        *   of the buffer.\n        */\n        BufferCommon.prototype.slice = function (start, end) {\n            if (typeof start === \"undefined\") { start = 0; }\n            if (typeof end === \"undefined\") { end = (this).length; }\n            var _this = this;\n\n            if (start < 0) {\n                start += _this.length;\n                if (start < 0) {\n                    start = 0;\n                }\n            }\n            if (end < 0) {\n                end += _this.length;\n                if (end < 0) {\n                    end = 0;\n                }\n            }\n            if (end > _this.length) {\n                end = _this.length;\n            }\n            if (start > end) {\n                start = end;\n            }\n\n            if (start < 0 || end < 0 || start >= _this.length || end > _this.length) {\n                throw new Error(\"Invalid slice indices.\");\n            }\n            return _this._slice(start, end);\n        };\n\n        /**\n        * Fills the buffer with the specified value. If the offset and end are not\n        * given it will fill the entire buffer.\n        * @param {(string|number)} value - The value to fill the buffer with\n        * @param {number} [offset=0]\n        * @param {number} [end=this.length]\n        */\n        BufferCommon.prototype.fill = function (value, offset, end) {\n            if (typeof offset === \"undefined\") { offset = 0; }\n            if (typeof end === \"undefined\") { end = (this).length; }\n            var i;\n            var valType = typeof value;\n            switch (valType) {\n                case \"string\":\n                    // Trim to a byte.\n                    value = value.charCodeAt(0) & 0xFF;\n                    break;\n                case \"number\":\n                    break;\n                default:\n                    throw new Error('Invalid argument to fill.');\n            }\n            (this)._fill(value, offset, end);\n        };\n        return BufferCommon;\n    })();\n    exports.BufferCommon = BufferCommon;\n});\n//# sourceMappingURL=buffer_common.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/buffer_old',[\"require\", \"exports\", './buffer_common', './api_error'], function(require, exports, __buffer_common__, __api_error__) {\n    \n    var buffer_common = __buffer_common__;\n    var api_error = __api_error__;\n    \n\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var FLOAT_POS_INFINITY = Math.pow(2, 128);\n    var FLOAT_NEG_INFINITY = -1 * FLOAT_POS_INFINITY;\n    var FLOAT_POS_INFINITY_AS_INT = 0x7F800000;\n    var FLOAT_NEG_INFINITY_AS_INT = -8388608;\n    var FLOAT_NaN_AS_INT = 0x7fc00000;\n\n    /**\n    * Emulation of Node's `Buffer` class for antiquated browsers without\n    * typed array support.\n    *\n    * @see http://nodejs.org/api/buffer.html\n    */\n    var Buffer = (function (_super) {\n        __extends(Buffer, _super);\n        function Buffer(arg1, arg2) {\n            if (typeof arg2 === \"undefined\") { arg2 = 'utf8'; }\n            _super.call(this);\n            this.offset = 0;\n            var i;\n\n            if (!(this instanceof Buffer)) {\n                return new Buffer(arg1, arg2);\n            }\n\n            if (typeof arg1 === 'number') {\n                if (arg1 !== (arg1 >>> 0)) {\n                    throw new TypeError('Buffer size must be a uint32.');\n                }\n                this.length = arg1;\n                this.buff = new Array(this.length);\n\n                // Need to explicitly initialize the array to zeroes.\n                this.fill(0);\n            } else if (arg1 instanceof Buffer) {\n                // constructor (data: Buffer);\n                this.buff = new Array(arg1.length);\n                for (i = 0; i < arg1.length; i++) {\n                    this.buff[i] = arg1.get(i);\n                }\n                this.length = arg1.length;\n            } else if (Array.isArray(arg1)) {\n                if (typeof arg2 === 'boolean' && arg2 === true) {\n                    // We are allowed to mutate arg1.\n                    this.buff = arg1;\n                } else {\n                    this.buff = arg1.slice(0);\n                }\n                this.length = arg1.length;\n            } else if (arg1 != null && typeof arg1 === 'object' && typeof arg1[0] === 'number') {\n                // constructor (data: arrayish object)\n                this.buff = new Array(arg1.length);\n                this.length = arg1.length;\n                for (i = 0; i < arg1.length; i++) {\n                    this.buff[i] = arg1[i];\n                }\n            } else if (typeof arg1 === 'string') {\n                // constructor (data: string, encoding?: string);\n                this.length = Buffer.byteLength(arg1, arg2);\n                this.buff = new Array(this.length);\n                this.write(arg1, 0, this.length, arg2);\n            } else {\n                throw new Error(\"Invalid argument to Buffer constructor: \" + arg1);\n            }\n        }\n        Buffer.prototype._getByteArray = function (start, end) {\n            start += this.offset;\n            end += this.offset;\n            return this.buff.slice(start, end);\n        };\n\n        Buffer.prototype._slice = function (start, end) {\n            start += this.offset;\n            end += this.offset;\n\n            // XXX: Bypass constructor logic; manually instantiate.\n            var buff = new Buffer(0);\n            buff.buff = this.buff;\n            buff.offset = start;\n            buff.length = end - start;\n            return buff;\n        };\n\n        Buffer.prototype._fill = function (value, start, end) {\n            for (var i = start; i < end; i++) {\n                this.writeUInt8(value, i);\n            }\n        };\n\n        // Numerical read/write methods\n        // @todo Actually care about noAssert.\n        Buffer.prototype.readUInt8 = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset);\n            offset += this.offset;\n            return this.buff[offset];\n        };\n\n        Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 1);\n            offset += this.offset;\n            return (this.buff[offset + 1] << 8) | this.buff[offset];\n        };\n\n        Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 1);\n            offset += this.offset;\n            return (this.buff[offset] << 8) | this.buff[offset + 1];\n        };\n\n        Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            offset += this.offset;\n            return ((this.buff[offset + 3] << 24) | (this.buff[offset + 2] << 16) | (this.buff[offset + 1] << 8) | this.buff[offset]) >>> 0;\n        };\n\n        Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            offset += this.offset;\n            return ((this.buff[offset] << 24) | (this.buff[offset + 1] << 16) | (this.buff[offset + 2] << 8) | this.buff[offset + 3]) >>> 0;\n        };\n\n        Buffer.prototype.readInt8 = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset);\n            offset += this.offset;\n            var val = this.buff[offset];\n            if (val & 0x80) {\n                // Sign bit is set, so perform sign extension.\n                return val | 0xFFFFFF80;\n            } else {\n                return val;\n            }\n        };\n\n        Buffer.prototype.readInt16LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            var val = this.readUInt16LE(offset, noAssert);\n            if (val & 0x8000) {\n                // Sign bit is set, so perform sign extension.\n                return val | 0xFFFF8000;\n            } else {\n                return val;\n            }\n        };\n\n        Buffer.prototype.readInt16BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            var val = this.readUInt16BE(offset, noAssert);\n            if (val & 0x8000) {\n                // Sign bit is set, so perform sign extension.\n                return val | 0xFFFF8000;\n            } else {\n                return val;\n            }\n        };\n\n        Buffer.prototype.readInt32LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.readUInt32LE(offset, noAssert) | 0;\n        };\n\n        Buffer.prototype.readInt32BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.readUInt32BE(offset, noAssert) | 0;\n        };\n\n        Buffer.prototype.readFloatLE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.intbits2float(this.readInt32LE(offset, noAssert));\n        };\n\n        Buffer.prototype.readFloatBE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.intbits2float(this.readInt32BE(offset, noAssert));\n        };\n\n        Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 7);\n            return this.longbits2double(this.readInt32LE(offset + 4, noAssert), this.readInt32LE(offset, noAssert));\n        };\n\n        Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 7);\n            return this.longbits2double(this.readInt32BE(offset, noAssert), this.readInt32BE(offset + 4, noAssert));\n        };\n\n        Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset);\n            offset += this.offset;\n            this.buff[offset] = value & 0xFF;\n        };\n\n        Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 1);\n            offset += this.offset;\n            this.buff[offset] = value & 0xFF;\n            this.buff[offset + 1] = (value >> 8) & 0xFF;\n        };\n\n        Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 1);\n            offset += this.offset;\n            this.buff[offset] = (value >> 8) & 0xFF;\n            this.buff[offset + 1] = value & 0xFF;\n        };\n\n        Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            offset += this.offset;\n            this.buff[offset] = (value >>> 0) & 0xFF;\n            this.buff[offset + 1] = (value >>> 8) & 0xFF;\n            this.buff[offset + 2] = (value >>> 16) & 0xFF;\n            this.buff[offset + 3] = (value >>> 24) & 0xFF;\n        };\n\n        Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            offset += this.offset;\n            this.buff[offset + 3] = (value >>> 0) & 0xFF;\n            this.buff[offset + 2] = (value >>> 8) & 0xFF;\n            this.buff[offset + 1] = (value >>> 16) & 0xFF;\n            this.buff[offset] = (value >>> 24) & 0xFF;\n        };\n\n        Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset);\n            offset += this.offset;\n\n            // Pack the sign bit as the highest bit.\n            // Note that we keep the highest bit in the value byte as the sign bit if it\n            // exists.\n            this.buff[offset] = (value & 0xFF) | ((value & 0x80000000) >>> 24);\n        };\n\n        Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 1);\n            offset += this.offset;\n            this.buff[offset] = value & 0xFF;\n\n            // Pack the sign bit as the highest bit.\n            // Note that we keep the highest bit in the value byte as the sign bit if it\n            // exists.\n            this.buff[offset + 1] = ((value >>> 8) & 0xFF) | ((value & 0x80000000) >>> 24);\n        };\n\n        Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 1);\n            offset += this.offset;\n            this.buff[offset + 1] = value & 0xFF;\n\n            // Pack the sign bit as the highest bit.\n            // Note that we keep the highest bit in the value byte as the sign bit if it\n            // exists.\n            this.buff[offset] = ((value >>> 8) & 0xFF) | ((value & 0x80000000) >>> 24);\n        };\n\n        Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            offset += this.offset;\n            this.buff[offset] = value & 0xFF;\n            this.buff[offset + 1] = (value >>> 8) & 0xFF;\n            this.buff[offset + 2] = (value >>> 16) & 0xFF;\n            this.buff[offset + 3] = (value >>> 24) & 0xFF;\n        };\n\n        Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            offset += this.offset;\n            this.buff[offset + 3] = value & 0xFF;\n            this.buff[offset + 2] = (value >>> 8) & 0xFF;\n            this.buff[offset + 1] = (value >>> 16) & 0xFF;\n            this.buff[offset] = (value >>> 24) & 0xFF;\n        };\n\n        Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            this.writeInt32LE(this.float2intbits(value), offset, noAssert);\n        };\n\n        Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 3);\n            this.writeInt32BE(this.float2intbits(value), offset, noAssert);\n        };\n\n        Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 7);\n            var doubleBits = this.double2longbits(value);\n            this.writeInt32LE(doubleBits[0], offset, noAssert);\n            this.writeInt32LE(doubleBits[1], offset + 4, noAssert);\n        };\n\n        Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.boundsCheck(offset + 7);\n            var doubleBits = this.double2longbits(value);\n            this.writeInt32BE(doubleBits[0], offset + 4, noAssert);\n            this.writeInt32BE(doubleBits[1], offset, noAssert);\n        };\n\n        Buffer.prototype.boundsCheck = function (bounds) {\n            if (bounds >= this.length) {\n                throw new ApiError(ErrorType.INVALID_PARAM, \"Index out of bounds.\");\n            }\n        };\n\n        Buffer.prototype.float2intbits = function (f_val) {\n            var exp, f_view, i_view, sig, sign;\n\n            if (f_val === 0) {\n                return 0;\n            }\n\n            if (f_val === Number.POSITIVE_INFINITY) {\n                return FLOAT_POS_INFINITY_AS_INT;\n            }\n            if (f_val === Number.NEGATIVE_INFINITY) {\n                return FLOAT_NEG_INFINITY_AS_INT;\n            }\n\n            if (isNaN(f_val)) {\n                return FLOAT_NaN_AS_INT;\n            }\n\n            // We have more bits of precision than a float, so below we round to\n            // the nearest significand. This appears to be what the x86\n            // Java does for normal floating point operations.\n            sign = f_val < 0 ? 1 : 0;\n            f_val = Math.abs(f_val);\n\n            if (f_val <= 1.1754942106924411e-38 && f_val >= 1.4012984643248170e-45) {\n                exp = 0;\n                sig = Math.round((f_val / Math.pow(2, -126)) * Math.pow(2, 23));\n                return (sign << 31) | (exp << 23) | sig;\n            } else {\n                // Regular FP numbers\n                exp = Math.floor(Math.log(f_val) / Math.LN2);\n                sig = Math.round((f_val / Math.pow(2, exp) - 1) * Math.pow(2, 23));\n                return (sign << 31) | ((exp + 127) << 23) | sig;\n            }\n        };\n\n        Buffer.prototype.double2longbits = function (d_val) {\n            var d_view, exp, high_bits, i_view, sig, sign;\n\n            if (d_val === 0) {\n                return [0, 0];\n            }\n            if (d_val === Number.POSITIVE_INFINITY) {\n                // High bits: 0111 1111 1111 0000 0000 0000 0000 0000\n                //  Low bits: 0000 0000 0000 0000 0000 0000 0000 0000\n                return [0, 2146435072];\n            } else if (d_val === Number.NEGATIVE_INFINITY) {\n                // High bits: 1111 1111 1111 0000 0000 0000 0000 0000\n                //  Low bits: 0000 0000 0000 0000 0000 0000 0000 0000\n                return [0, -1048576];\n            } else if (isNaN(d_val)) {\n                // High bits: 0111 1111 1111 1000 0000 0000 0000 0000\n                //  Low bits: 0000 0000 0000 0000 0000 0000 0000 0000\n                return [0, 2146959360];\n            }\n            sign = d_val < 0 ? 1 << 31 : 0;\n            d_val = Math.abs(d_val);\n\n            if (d_val <= 2.2250738585072010e-308 && d_val >= 5.0000000000000000e-324) {\n                exp = 0;\n                sig = (d_val / Math.pow(2, -1022)) * Math.pow(2, 52);\n            } else {\n                exp = Math.floor(Math.log(d_val) / Math.LN2);\n\n                if (d_val < Math.pow(2, exp)) {\n                    exp = exp - 1;\n                }\n                sig = (d_val / Math.pow(2, exp) - 1) * Math.pow(2, 52);\n                exp = (exp + 1023) << 20;\n            }\n\n            // Simulate >> 32\n            high_bits = ((sig * Math.pow(2, -32)) | 0) | sign | exp;\n            return [sig & 0xFFFF, high_bits];\n        };\n\n        Buffer.prototype.intbits2float = function (int32) {\n            if (int32 === FLOAT_POS_INFINITY_AS_INT) {\n                return Number.POSITIVE_INFINITY;\n            } else if (int32 === FLOAT_NEG_INFINITY_AS_INT) {\n                return Number.NEGATIVE_INFINITY;\n            }\n            var sign = (int32 & 0x80000000) >>> 31;\n            var exponent = (int32 & 0x7F800000) >>> 23;\n            var significand = int32 & 0x007FFFFF;\n            var value;\n            if (exponent === 0) {\n                value = Math.pow(-1, sign) * significand * Math.pow(2, -149);\n            } else {\n                value = Math.pow(-1, sign) * (1 + significand * Math.pow(2, -23)) * Math.pow(2, exponent - 127);\n            }\n\n            if (value < FLOAT_NEG_INFINITY || value > FLOAT_POS_INFINITY) {\n                value = NaN;\n            }\n            return value;\n        };\n\n        Buffer.prototype.longbits2double = function (uint32_a, uint32_b) {\n            var sign = (uint32_a & 0x80000000) >>> 31;\n            var exponent = (uint32_a & 0x7FF00000) >>> 20;\n            var significand = ((uint32_a & 0x000FFFFF) * Math.pow(2, 32)) + uint32_b;\n\n            if (exponent === 0 && significand === 0) {\n                return 0;\n            }\n            if (exponent === 2047) {\n                if (significand === 0) {\n                    if (sign === 1) {\n                        return Number.NEGATIVE_INFINITY;\n                    }\n                    return Number.POSITIVE_INFINITY;\n                } else {\n                    return NaN;\n                }\n            }\n            if (exponent === 0)\n                return Math.pow(-1, sign) * significand * Math.pow(2, -1074);\n            return Math.pow(-1, sign) * (1 + significand * Math.pow(2, -52)) * Math.pow(2, exponent - 1023);\n        };\n        Buffer.INSPECT_MAX_BYTES = 0;\n        return Buffer;\n    })(buffer_common.BufferCommon);\n    exports.Buffer = Buffer;\n});\n//# sourceMappingURL=buffer_old.js.map\n;","\n/**\n* @module core/api_error\n*/\ndefine('core/api_error',[\"require\", \"exports\"], function(require, exports) {\n    /**\n    * Encapsulates all of the errors that BrowserFS can encounter.\n    * @readonly\n    * @enum {number} ErrorType\n    */\n    (function (ErrorType) {\n        // XHR ERROR STATUSES\n        // These error messages correspond to xhr.status, as in Dropbox-JS. They should\n        // be used even for filesystems that do not use XHR (note that many of the\n        // names have been changed to be more generic to the filesystem abstraction)\n        // Status value indicating an error at the XMLHttpRequest layer.\n        //\n        // This indicates a network transmission error on modern browsers. Internet\n        // Explorer might cause this code to be reported on some API server errors.\n        ErrorType[ErrorType[\"NETWORK_ERROR\"] = 0] = \"NETWORK_ERROR\";\n\n        // Status value indicating an invalid input parameter.\n        ErrorType[ErrorType[\"INVALID_PARAM\"] = 400] = \"INVALID_PARAM\";\n\n        // Status value indicating an expired or invalid OAuth token.\n        //\n        // The OAuth token used for the request will never become valid again, so the\n        // user should be re-authenticated.\n        ErrorType[ErrorType[\"INVALID_TOKEN\"] = 401] = \"INVALID_TOKEN\";\n\n        // Status value indicating an authentication error of some sort.\n        ErrorType[ErrorType[\"AUTH_ERROR\"] = 403] = \"AUTH_ERROR\";\n\n        // Status value indicating that a file or path was not found in the filesystem.\n        //\n        // This happens when trying to read from a non-existing file, readdir a\n        // non-existing directory, write a file into a non-existing directory, etc.\n        ErrorType[ErrorType[\"NOT_FOUND\"] = 404] = \"NOT_FOUND\";\n\n        // Status value indicating that the filesystem is full to capacity.\n        ErrorType[ErrorType[\"DRIVE_FULL\"] = 507] = \"DRIVE_FULL\";\n\n        // Indicates that the given method is not supported on the current filesystem.\n        ErrorType[ErrorType[\"NOT_SUPPORTED\"] = 405] = \"NOT_SUPPORTED\";\n\n        // BROWSERFS ERROR STATUSES\n        // The numbers here have no real meaning; they are just unique identifiers.\n        // @todo Add any needed error types.\n        // Indicates that you lack sufficient permissions to perform the indicated\n        // task. This could be due to a filemode error.\n        ErrorType[ErrorType[\"PERMISSIONS_ERROR\"] = 900] = \"PERMISSIONS_ERROR\";\n    })(exports.ErrorType || (exports.ErrorType = {}));\n    var ErrorType = exports.ErrorType;\n\n    var ApiError = (function () {\n        /**\n        * Represents a BrowserFS error. Passed back to applications after a failed\n        * call to the BrowserFS API.\n        *\n        * Error codes were stolen from Dropbox-JS, but may be changed in the future\n        * for better Node compatibility...\n        * @see https://raw.github.com/dropbox/dropbox-js/master/src/api_error.coffee\n        * @todo Switch to Node error codes.\n        * @constructor ApiError\n        * @param {number} type - The type of error. Use one of the static fields of this class as the type.\n        * @param {string} [message] - A descriptive error message.\n        */\n        function ApiError(type, message) {\n            this.type = type;\n            if (message != null) {\n                this.message = message;\n            }\n            this.code = 'ENOENT';\n        }\n        /**\n        * @method ApiError#toString\n        * @return {string} A friendly error message.\n        */\n        ApiError.prototype.toString = function () {\n            var typeStr = (function () {\n                switch (this.type) {\n                    case ErrorType.NETWORK_ERROR:\n                        return 'Network Error';\n                    case ErrorType.INVALID_PARAM:\n                        return 'Invalid Param';\n                    case ErrorType.INVALID_TOKEN:\n                        return 'Invalid Token';\n                    case ErrorType.AUTH_ERROR:\n                        return 'Auth Error';\n                    case ErrorType.NOT_FOUND:\n                        return 'Not Found';\n                    case ErrorType.DRIVE_FULL:\n                        return 'Drive Full';\n                    case ErrorType.NOT_SUPPORTED:\n                        return 'Not Supported';\n                    case ErrorType.PERMISSIONS_ERROR:\n                        return 'Permissions Error';\n                    default:\n                        return 'Error';\n                }\n            }).call(this);\n            return \"BrowserFS \" + typeStr + \": \" + this.message;\n        };\n        return ApiError;\n    })();\n    exports.ApiError = ApiError;\n});\n//# sourceMappingURL=api_error.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/buffer_modern',[\"require\", \"exports\", './buffer_common'], function(require, exports, __buffer_common__) {\n    \n    var buffer_common = __buffer_common__;\n    \n\n    /**\n    * Emulation of Node's `Buffer` class. Normally, this is declared globally, but I\n    * make that behavior optional.\n    *\n    * The buffer is backed by a `DataView`; we have a polyfill in `vendor` that\n    * handles compatibility for us.\n    *\n    * @see http://nodejs.org/api/buffer.html\n    * @todo Add option to add array accessors, if someone doesn't mind the *huge*\n    *       speed hit for compatibility.\n    * @class\n    */\n    var Buffer = (function (_super) {\n        __extends(Buffer, _super);\n        function Buffer(arg1, arg2) {\n            if (typeof arg2 === \"undefined\") { arg2 = 'utf8'; }\n            _super.call(this);\n            var i;\n\n            if (!(this instanceof Buffer)) {\n                return new Buffer(arg1, arg2);\n            }\n\n            if (typeof arg1 === 'number') {\n                if (arg1 !== (arg1 >>> 0)) {\n                    throw new TypeError('Buffer size must be a uint32.');\n                }\n                this.length = arg1;\n                this.buff = new DataView(new ArrayBuffer(this.length));\n            } else if (arg1 instanceof DataView) {\n                // constructor (data: DataView);\n                this.buff = arg1;\n                this.length = arg1.byteLength;\n            } else if (arg1 instanceof ArrayBuffer) {\n                // constructor (data: ArrayBuffer);\n                this.buff = new DataView(arg1);\n                this.length = arg1.byteLength;\n            } else if (arg1 instanceof Buffer) {\n                // constructor (data: Buffer);\n                this.buff = new DataView(new ArrayBuffer(arg1.length));\n                for (i = 0; i < arg1.length; i++) {\n                    this.buff.setUint8(i, arg1.get(i));\n                }\n                this.length = arg1.length;\n            } else if (Array.isArray(arg1) || (arg1 != null && typeof arg1 === 'object' && typeof arg1[0] === 'number')) {\n                // constructor (data: number[]);\n                this.buff = new DataView(new ArrayBuffer(arg1.length));\n                for (i = 0; i < arg1.length; i++) {\n                    this.buff.setUint8(i, arg1[i]);\n                }\n                this.length = arg1.length;\n            } else if (typeof arg1 === 'string') {\n                // constructor (data: string, encoding?: string);\n                this.length = Buffer.byteLength(arg1, arg2);\n                this.buff = new DataView(new ArrayBuffer(this.length));\n                this.write(arg1, 0, this.length, arg2);\n            } else {\n                throw new Error(\"Invalid argument to Buffer constructor: \" + arg1);\n            }\n        }\n        Buffer.prototype._getByteArray = function (start, end) {\n            var len = end - start;\n            var byteArr = new Array(len);\n            for (var i = 0; i < len; i++) {\n                byteArr[i] = this.readUInt8(start + i);\n            }\n            return byteArr;\n        };\n\n        Buffer.prototype._slice = function (start, end) {\n            return new Buffer(new DataView(this.buff.buffer, this.buff.byteOffset + start, end - start));\n        };\n\n        Buffer.prototype._fill = function (value, start, end) {\n            var i;\n            var val32 = value | (value << 8) | (value << 16) | (value << 24);\n            var num32 = Math.floor((end - start) / 4);\n            var remSt = start + num32 * 4;\n\n            for (i = 0; i < num32; i++) {\n                this.writeUInt32LE(val32, start + i * 4);\n            }\n            for (i = remSt; i < end; i++) {\n                this.writeUInt8(value, i);\n            }\n        };\n\n        // Numerical read/write methods\n        // @todo Actually care about noAssert.\n        Buffer.prototype.readUInt8 = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getUint8(offset);\n        };\n\n        Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getUint16(offset, true);\n        };\n\n        Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getUint16(offset, false);\n        };\n\n        Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getUint32(offset, true);\n        };\n\n        Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getUint32(offset, false);\n        };\n\n        Buffer.prototype.readInt8 = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getInt8(offset);\n        };\n\n        Buffer.prototype.readInt16LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getInt16(offset, true);\n        };\n\n        Buffer.prototype.readInt16BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getInt16(offset, false);\n        };\n\n        Buffer.prototype.readInt32LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getInt32(offset, true);\n        };\n\n        Buffer.prototype.readInt32BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getInt32(offset, false);\n        };\n\n        Buffer.prototype.readFloatLE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getFloat32(offset, true);\n        };\n\n        Buffer.prototype.readFloatBE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getFloat32(offset, false);\n        };\n\n        Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getFloat64(offset, true);\n        };\n\n        Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            return this.buff.getFloat64(offset, false);\n        };\n\n        Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setUint8(offset, value);\n        };\n\n        Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setUint16(offset, value, true);\n        };\n\n        Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setUint16(offset, value, false);\n        };\n\n        Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setUint32(offset, value, true);\n        };\n\n        Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setUint32(offset, value, false);\n        };\n\n        Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setInt8(offset, value);\n        };\n\n        Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setInt16(offset, value, true);\n        };\n\n        Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setInt16(offset, value, false);\n        };\n\n        Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setInt32(offset, value, true);\n        };\n\n        Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setInt32(offset, value, false);\n        };\n\n        Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setFloat32(offset, value, true);\n        };\n\n        Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setFloat32(offset, value, false);\n        };\n\n        Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setFloat64(offset, value, true);\n        };\n\n        Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            this.buff.setFloat64(offset, value, false);\n        };\n        Buffer.INSPECT_MAX_BYTES = 0;\n        return Buffer;\n    })(buffer_common.BufferCommon);\n    exports.Buffer = Buffer;\n});\n//# sourceMappingURL=buffer_modern.js.map\n;","\ndefine('core/buffer',[\"require\", \"exports\", './buffer_old', './buffer_modern'], function(require, exports, __buffer_old__, __buffer_modern__) {\n    /**\n    * Buffer module. Exports an appropriate version of Buffer for the current\n    * platform.\n    */\n    var buffer_old = __buffer_old__;\n    var buffer_modern = __buffer_modern__;\n\n    exports.OldBuffer = buffer_old.Buffer;\n    exports.ModernBuffer = buffer_modern.Buffer;\n\n    // Typing copied from node.d.ts.\n    exports.Buffer = typeof ArrayBuffer !== 'undefined' ? buffer_modern.Buffer : buffer_old.Buffer;\n});\n//# sourceMappingURL=buffer.js.map\n;","\ndefine('core/file_flag',[\"require\", \"exports\", './api_error'], function(require, exports, __api_error__) {\n    var api_error = __api_error__;\n\n    /**\n    * @class\n    */\n    (function (ActionType) {\n        // Indicates that the code should not do anything.\n        ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\n\n        // Indicates that the code should throw an exception.\n        ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\n\n        // Indicates that the code should truncate the file, but only if it is a file.\n        ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\n\n        // Indicates that the code should create the file.\n        ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\n    })(exports.ActionType || (exports.ActionType = {}));\n    var ActionType = exports.ActionType;\n\n    /**\n    * Represents one of the following file flags. A convenience object.\n    *\n    * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\n    * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\n    * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\n    * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\n    * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n    * * `'wx'` - Like 'w' but opens the file in exclusive mode.\n    * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n    * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\n    * * `'a'` - Open file for appending. The file is created if it does not exist.\n    * * `'ax'` - Like 'a' but opens the file in exclusive mode.\n    * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\n    * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\n    *\n    * Exclusive mode ensures that the file path is newly created.\n    * @class\n    */\n    var FileFlag = (function () {\n        /**\n        * This should never be called directly.\n        * @param [String] modeStr The string representing the mode\n        * @throw [BrowserFS.ApiError] when the mode string is invalid\n        */\n        function FileFlag(flagStr) {\n            this.flagStr = flagStr;\n            if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\n                throw new api_error.ApiError(api_error.ErrorType.INVALID_PARAM, \"Invalid flag: \" + flagStr);\n            }\n        }\n        FileFlag.getFileFlag = /**\n        * Get an object representing the given file mode.\n        * @param [String] modeStr The string representing the mode\n        * @return [BrowserFS.FileMode] The FileMode object representing the mode\n        * @throw [BrowserFS.ApiError] when the mode string is invalid\n        */\n        function (flagStr) {\n            if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\n                return FileFlag.flagCache[flagStr];\n            }\n            return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\n        };\n\n        /**\n        * Returns true if the file is readable.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isReadable = function () {\n            return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\n        };\n\n        /**\n        * Returns true if the file is writeable.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isWriteable = function () {\n            return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\n        };\n\n        /**\n        * Returns true if the file mode should truncate.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isTruncating = function () {\n            return this.flagStr.indexOf('w') !== -1;\n        };\n\n        /**\n        * Returns true if the file is appendable.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isAppendable = function () {\n            return this.flagStr.indexOf('a') !== -1;\n        };\n\n        /**\n        * Returns true if the file is open in synchronous mode.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isSynchronous = function () {\n            return this.flagStr.indexOf('s') !== -1;\n        };\n\n        /**\n        * Returns true if the file is open in exclusive mode.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isExclusive = function () {\n            return this.flagStr.indexOf('x') !== -1;\n        };\n\n        /**\n        * Returns one of the static fields on this object that indicates the\n        * appropriate response to the path existing.\n        * @return [Number]\n        */\n        FileFlag.prototype.pathExistsAction = function () {\n            if (this.isExclusive()) {\n                return ActionType.THROW_EXCEPTION;\n            } else if (this.isTruncating()) {\n                return ActionType.TRUNCATE_FILE;\n            } else {\n                return ActionType.NOP;\n            }\n        };\n\n        /**\n        * Returns one of the static fields on this object that indicates the\n        * appropriate response to the path not existing.\n        * @return [Number]\n        */\n        FileFlag.prototype.pathNotExistsAction = function () {\n            if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\n                return ActionType.CREATE_FILE;\n            } else {\n                return ActionType.THROW_EXCEPTION;\n            }\n        };\n        FileFlag.flagCache = {};\n\n        FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\n        return FileFlag;\n    })();\n    exports.FileFlag = FileFlag;\n});\n//# sourceMappingURL=file_flag.js.map\n;","\ndefine('core/node_process',[\"require\", \"exports\"], function(require, exports) {\n    var path = null;\n\n    /**\n    * Partial implementation of Node's `process` module.\n    * We implement the portions that are relevant for the filesystem.\n    * @see http://nodejs.org/api/process.html\n    * @class\n    */\n    var Process = (function () {\n        function Process() {\n            this.startTime = Date.now();\n            this._cwd = '/';\n            /**\n            * Returns what platform you are running on.\n            * @return [String]\n            */\n            this.platform = 'browser';\n            this.argv = [];\n        }\n        /**\n        * Changes the current working directory.\n        *\n        * **Note**: BrowserFS does not validate that the directory actually exists.\n        *\n        * @example Usage example\n        *   console.log('Starting directory: ' + process.cwd());\n        *   process.chdir('/tmp');\n        *   console.log('New directory: ' + process.cwd());\n        * @param [String] dir The directory to change to.\n        */\n        Process.prototype.chdir = function (dir) {\n            if (path === null) {\n                path = require('./node_path').path;\n            }\n            this._cwd = path.resolve(dir);\n        };\n\n        /**\n        * Returns the current working directory.\n        * @example Usage example\n        *   console.log('Current directory: ' + process.cwd());\n        * @return [String] The current working directory.\n        */\n        Process.prototype.cwd = function () {\n            return this._cwd;\n        };\n\n        /**\n        * Number of seconds BrowserFS has been running.\n        * @return [Number]\n        */\n        Process.prototype.uptime = function () {\n            return ((Date.now() - this.startTime) / 1000) | 0;\n        };\n\n        Process.prototype.stdout = function (print) {\n            window.alert(print);\n        };\n        Process.prototype.stdin = function (prompt) {\n            return window.prompt(prompt ? prompt : 'Input: ');\n        };\n        return Process;\n    })();\n    exports.Process = Process;\n\n    // process is a singleton.\n    exports.process = new Process();\n});\n//# sourceMappingURL=node_process.js.map\n;","\ndefine('core/node_path',[\"require\", \"exports\", './node_process'], function(require, exports, __node_process__) {\n    var node_process = __node_process__;\n    var process = node_process.process;\n\n    /**\n    * Emulates Node's `path` module. This module contains utilities for handling and\n    * transforming file paths. **All** of these methods perform only string\n    * transformations. The file system is not consulted to check whether paths are\n    * valid.\n    * @see http://nodejs.org/api/path.html\n    * @class\n    */\n    var path = (function () {\n        function path() {\n        }\n        path.normalize = /**\n        * Normalize a string path, taking care of '..' and '.' parts.\n        *\n        * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n        * @example Usage example\n        *   path.normalize('/foo/bar//baz/asdf/quux/..')\n        *   // returns\n        *   '/foo/bar/baz/asdf'\n        * @param [String] p The path to normalize.\n        * @return [String]\n        */\n        function (p) {\n            if (p === '') {\n                p = '.';\n            }\n\n            // It's very important to know if the path is relative or not, since it\n            // changes how we process .. and reconstruct the split string.\n            var absolute = p.charAt(0) === path.sep;\n\n            // Remove repeated //s\n            p = path._removeDuplicateSeps(p);\n\n            // Try to remove as many '../' as possible, and remove '.' completely.\n            var components = p.split(path.sep);\n            var goodComponents = [];\n            for (var idx = 0; idx < components.length; idx++) {\n                var c = components[idx];\n                if (c === '.') {\n                    continue;\n                } else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\n                    // In the absolute case: Path is relative to root, so we may pop even if\n                    // goodComponents is empty (e.g. /../ => /)\n                    // In the relative case: We're getting rid of a directory that preceded\n                    // it (e.g. /foo/../bar -> /bar)\n                    goodComponents.pop();\n                } else {\n                    goodComponents.push(c);\n                }\n            }\n\n            if (!absolute && goodComponents.length < 2) {\n                switch (goodComponents.length) {\n                    case 1:\n                        if (goodComponents[0] === '') {\n                            goodComponents.unshift('.');\n                        }\n                        break;\n                    default:\n                        goodComponents.push('.');\n                }\n            }\n            p = goodComponents.join(path.sep);\n            if (absolute && p.charAt(0) !== path.sep) {\n                p = path.sep + p;\n            }\n            return p;\n        };\n\n        path.join = /**\n        * Join all arguments together and normalize the resulting path.\n        *\n        * Arguments must be strings.\n        * @example Usage\n        *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n        *   // returns\n        *   '/foo/bar/baz/asdf'\n        *\n        *   path.join('foo', {}, 'bar')\n        *   // throws exception\n        *   TypeError: Arguments to path.join must be strings\n        * @param [String,...] paths Each component of the path\n        * @return [String]\n        */\n        function () {\n            var paths = [];\n            for (var _i = 0; _i < (arguments.length - 0); _i++) {\n                paths[_i] = arguments[_i + 0];\n            }\n            // Required: Prune any non-strings from the path. I also prune empty segments\n            // so we can do a simple join of the array.\n            var processed = [];\n            for (var i = 0; i < paths.length; i++) {\n                var segment = paths[i];\n                if (typeof segment !== 'string') {\n                    throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\n                } else if (segment !== '') {\n                    processed.push(segment);\n                }\n            }\n            return path.normalize(processed.join(path.sep));\n        };\n\n        path.resolve = /**\n        * Resolves to to an absolute path.\n        *\n        * If to isn't already absolute from arguments are prepended in right to left\n        * order, until an absolute path is found. If after using all from paths still\n        * no absolute path is found, the current working directory is used as well.\n        * The resulting path is normalized, and trailing slashes are removed unless\n        * the path gets resolved to the root directory. Non-string arguments are\n        * ignored.\n        *\n        * Another way to think of it is as a sequence of cd commands in a shell.\n        *\n        *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n        *\n        * Is similar to:\n        *\n        *     cd foo/bar\n        *     cd /tmp/file/\n        *     cd ..\n        *     cd a/../subfile\n        *     pwd\n        *\n        * The difference is that the different paths don't need to exist and may also\n        * be files.\n        * @example Usage example\n        *   path.resolve('/foo/bar', './baz')\n        *   // returns\n        *   '/foo/bar/baz'\n        *\n        *   path.resolve('/foo/bar', '/tmp/file/')\n        *   // returns\n        *   '/tmp/file'\n        *\n        *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n        *   // if currently in /home/myself/node, it returns\n        *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\n        * @param [String,...] paths\n        * @return [String]\n        */\n        function () {\n            var paths = [];\n            for (var _i = 0; _i < (arguments.length - 0); _i++) {\n                paths[_i] = arguments[_i + 0];\n            }\n            // Monitor for invalid paths, throw out empty paths, and look for the *last*\n            // absolute path that we see.\n            var processed = [];\n            for (var i = 0; i < paths.length; i++) {\n                var p = paths[i];\n                if (typeof p !== 'string') {\n                    throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\n                } else if (p !== '') {\n                    if (p.charAt(0) === path.sep) {\n                        processed = [];\n                    }\n                    processed.push(p);\n                }\n            }\n\n            // Special: Remove trailing slash unless it's the root\n            var resolved = path.normalize(processed.join(path.sep));\n            if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {\n                return resolved.substr(0, resolved.length - 1);\n            }\n\n            if (resolved.charAt(0) !== path.sep) {\n                if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {\n                    resolved = resolved.length === 1 ? '' : resolved.substr(2);\n                }\n\n                // Append the current directory, which *must* be an absolute path.\n                var cwd = process.cwd();\n                if (resolved !== '') {\n                    // cwd will never end in a /... unless it's the root.\n                    resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);\n                } else {\n                    resolved = cwd;\n                }\n            }\n            return resolved;\n        };\n\n        path.relative = /**\n        * Solve the relative path from from to to.\n        *\n        * At times we have two absolute paths, and we need to derive the relative path\n        * from one to the other. This is actually the reverse transform of\n        * path.resolve, which means we see that:\n        *\n        *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\n        *\n        * @example Usage example\n        *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n        *   // returns\n        *   '..\\\\..\\\\impl\\\\bbb'\n        *\n        *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n        *   // returns\n        *   '../../impl/bbb'\n        * @param [String] from\n        * @param [String] to\n        * @return [String]\n        */\n        function (from, to) {\n            var i;\n\n            // Alright. Let's resolve these two to absolute paths and remove any\n            // weirdness.\n            from = path.resolve(from);\n            to = path.resolve(to);\n            var fromSegs = from.split(path.sep);\n            var toSegs = to.split(path.sep);\n\n            // Remove the first segment on both, as it's '' (both are absolute paths)\n            toSegs.shift();\n            fromSegs.shift();\n\n            // There are two segments to this path:\n            // * Going *up* the directory hierarchy with '..'\n            // * Going *down* the directory hierarchy with foo/baz/bat.\n            var upCount = 0;\n            var downSegs = [];\n\n            for (i = 0; i < fromSegs.length; i++) {\n                var seg = fromSegs[i];\n                if (seg === toSegs[i]) {\n                    continue;\n                }\n\n                // The rest of 'from', including the current element, indicates how many\n                // directories we need to go up.\n                upCount = fromSegs.length - i;\n                break;\n            }\n\n            // The rest of 'to' indicates where we need to change to. We place this\n            // outside of the loop, as toSegs.length may be greater than fromSegs.length.\n            downSegs = toSegs.slice(i);\n\n            if (fromSegs.length === 1 && fromSegs[0] === '') {\n                upCount = 0;\n            }\n\n            if (upCount > fromSegs.length) {\n                upCount = fromSegs.length;\n            }\n\n            // Create the final string!\n            var rv = '';\n            for (i = 0; i < upCount; i++) {\n                rv += '../';\n            }\n            rv += downSegs.join(path.sep);\n\n            if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {\n                rv = rv.substr(0, rv.length - 1);\n            }\n            return rv;\n        };\n\n        path.dirname = /**\n        * Return the directory name of a path. Similar to the Unix `dirname` command.\n        *\n        * Note that BrowserFS does not validate if the path is actually a valid\n        * directory.\n        * @example Usage example\n        *   path.dirname('/foo/bar/baz/asdf/quux')\n        *   // returns\n        *   '/foo/bar/baz/asdf'\n        * @param [String] p The path to get the directory name of.\n        * @return [String]\n        */\n        function (p) {\n            // We get rid of //, but we don't modify anything else (e.g. any extraneous .\n            // and ../ are kept intact)\n            p = path._removeDuplicateSeps(p);\n            var absolute = p.charAt(0) === path.sep;\n            var sections = p.split(path.sep);\n\n            if (sections.pop() === '' && sections.length > 0) {\n                sections.pop();\n            }\n            if (sections.length > 1) {\n                return sections.join(path.sep);\n            } else if (absolute) {\n                return path.sep;\n            } else {\n                return '.';\n            }\n        };\n\n        path.basename = /**\n        * Return the last portion of a path. Similar to the Unix basename command.\n        * @example Usage example\n        *   path.basename('/foo/bar/baz/asdf/quux.html')\n        *   // returns\n        *   'quux.html'\n        *\n        *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n        *   // returns\n        *   'quux'\n        * @param [String] p\n        * @param [String?] ext\n        * @return [String]\n        */\n        function (p, ext) {\n            if (typeof ext === \"undefined\") { ext = \"\"; }\n            if (p === '') {\n                return p;\n            }\n\n            // Normalize the string first to remove any weirdness.\n            p = path.normalize(p);\n\n            // Get the last part of the string.\n            var sections = p.split(path.sep);\n            var lastPart = sections[sections.length - 1];\n\n            if (lastPart === '' && sections.length > 1) {\n                return sections[sections.length - 2];\n            }\n\n            if (ext.length > 0) {\n                var lastPartExt = lastPart.substr(lastPart.length - ext.length);\n                if (lastPartExt === ext) {\n                    return lastPart.substr(0, lastPart.length - ext.length);\n                }\n            }\n            return lastPart;\n        };\n\n        path.extname = /**\n        * Return the extension of the path, from the last '.' to end of string in the\n        * last portion of the path. If there is no '.' in the last portion of the path\n        * or the first character of it is '.', then it returns an empty string.\n        * @example Usage example\n        *   path.extname('index.html')\n        *   // returns\n        *   '.html'\n        *\n        *   path.extname('index.')\n        *   // returns\n        *   '.'\n        *\n        *   path.extname('index')\n        *   // returns\n        *   ''\n        * @param [String] p\n        * @return [String]\n        */\n        function (p) {\n            p = path.normalize(p);\n            var sections = p.split(path.sep);\n            p = sections.pop();\n\n            if (p === '' && sections.length > 0) {\n                p = sections.pop();\n            }\n            if (p === '..') {\n                return '';\n            }\n            var i = p.lastIndexOf('.');\n            if (i === -1 || i === 0) {\n                return '';\n            }\n            return p.substr(i);\n        };\n\n        path.isAbsolute = /**\n        * Checks if the given path is an absolute path.\n        *\n        * Despite not being documented, this is a tested part of Node's path API.\n        * @param [String] p\n        * @return [Boolean] True if the path appears to be an absolute path.\n        */\n        function (p) {\n            return p.length > 0 && p.charAt(0) === path.sep;\n        };\n\n        path._makeLong = /**\n        * Unknown. Undocumented.\n        */\n        function (p) {\n            return p;\n        };\n\n        path._removeDuplicateSeps = function (p) {\n            p = p.replace(this._replaceRegex, this.sep);\n            return p;\n        };\n        path.sep = '/';\n\n        path._replaceRegex = new RegExp(\"//+\", 'g');\n\n        path.delimiter = ':';\n        return path;\n    })();\n    exports.path = path;\n});\n//# sourceMappingURL=node_path.js.map\n;","\ndefine('core/node_fs',[\"require\", \"exports\", './api_error', './file_flag', './buffer', './node_path'], function(require, exports, __api_error__, __file_flag__, __buffer__, __node_path__) {\n    \n    var api_error = __api_error__;\n    \n    var file_flag = __file_flag__;\n    var buffer = __buffer__;\n    var node_path = __node_path__;\n    \n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var FileFlag = file_flag.FileFlag;\n    var Buffer = buffer.Buffer;\n    var path = node_path.path;\n\n    /**\n    * Wraps a callback with a setImmediate call.\n    * @param [Function] cb The callback to wrap.\n    * @param [Number] numArgs The number of arguments that the callback takes.\n    * @return [Function] The wrapped callback.\n    */\n    function wrapCb(cb, numArgs) {\n        if (typeof cb !== 'function') {\n            throw new ApiError(ErrorType.INVALID_PARAM, 'Callback must be a function.');\n        }\n\n        if (typeof __numWaiting === 'undefined') {\n            __numWaiting = 0;\n        }\n        __numWaiting++;\n\n        switch (numArgs) {\n            case 1:\n                return function (arg1) {\n                    setImmediate(function () {\n                        __numWaiting--;\n                        return cb(arg1);\n                    });\n                };\n            case 2:\n                return function (arg1, arg2) {\n                    setImmediate(function () {\n                        __numWaiting--;\n                        return cb(arg1, arg2);\n                    });\n                };\n            case 3:\n                return function (arg1, arg2, arg3) {\n                    setImmediate(function () {\n                        __numWaiting--;\n                        return cb(arg1, arg2, arg3);\n                    });\n                };\n            default:\n                throw new Error('Invalid invocation of wrapCb.');\n        }\n    }\n\n    /**\n    * Checks if the fd is valid.\n    * @param [BrowserFS.File] fd A file descriptor (in BrowserFS, it's a File object)\n    * @return [Boolean, BrowserFS.ApiError] Returns `true` if the FD is OK,\n    *   otherwise returns an ApiError.\n    */\n    function checkFd(fd) {\n        if (typeof fd['write'] !== 'function') {\n            throw new ApiError(ErrorType.INVALID_PARAM, 'Invalid file descriptor.');\n        }\n    }\n\n    function normalizeMode(mode, def) {\n        switch (typeof mode) {\n            case 'number':\n                // (path, flag, mode, cb?)\n                return mode;\n            case 'string':\n                // (path, flag, modeString, cb?)\n                var trueMode = parseInt(mode, 8);\n                if (trueMode !== NaN) {\n                    return trueMode;\n                }\n\n            default:\n                return def;\n        }\n    }\n\n    function normalizePath(p) {\n        if (p.indexOf('\\u0000') >= 0) {\n            throw new ApiError(ErrorType.INVALID_PARAM, 'Path must be a string without null bytes.');\n        } else if (p === '') {\n            throw new ApiError(ErrorType.INVALID_PARAM, 'Path must not be empty.');\n        }\n        return path.resolve(p);\n    }\n\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\n        switch (typeof options) {\n            case 'object':\n                return {\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n                    mode: normalizeMode(options['mode'], defMode)\n                };\n            case 'string':\n                return {\n                    encoding: options,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            default:\n                return {\n                    encoding: defEnc,\n                    flag: defFlag,\n                    mode: defMode\n                };\n        }\n    }\n\n    // The default callback is a NOP.\n    function nopCb() {\n    }\n    ;\n\n    /**\n    * The node frontend to all filesystems.\n    * This layer handles:\n    *\n    * * Sanity checking inputs.\n    * * Normalizing paths.\n    * * Resetting stack depth for asynchronous operations which may not go through\n    *   the browser by wrapping all input callbacks using `setImmediate`.\n    * * Performing the requested operation through the filesystem or the file\n    *   descriptor, as appropriate.\n    * * Handling optional arguments and setting default arguments.\n    * @see http://nodejs.org/api/fs.html\n    * @class\n    */\n    var fs = (function () {\n        function fs() {\n        }\n        fs._initialize = function (rootFS) {\n            if (!(rootFS).constructor.isAvailable()) {\n                throw new ApiError(ErrorType.INVALID_PARAM, 'Tried to instantiate BrowserFS with an unavailable file system.');\n            }\n            return fs.root = rootFS;\n        };\n\n        fs._toUnixTimestamp = function (time) {\n            if (typeof time === 'number') {\n                return time;\n            } else if (time instanceof Date) {\n                return time.getTime() / 1000;\n            }\n            throw new Error(\"Cannot parse time: \" + time);\n        };\n\n        fs.getRootFS = /**\n        * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n        * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n        *   not been initialized.\n        */\n        function () {\n            if (fs.root) {\n                return fs.root;\n            } else {\n                return null;\n            }\n        };\n\n        fs.rename = // FILE OR DIRECTORY METHODS\n        /**\n        * Asynchronous rename. No arguments other than a possible exception are given\n        * to the completion callback.\n        * @param [String] oldPath\n        * @param [String] newPath\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (oldPath, newPath, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                fs.root.rename(normalizePath(oldPath), normalizePath(newPath), newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.renameSync = /**\n        * Synchronous rename.\n        * @param [String] oldPath\n        * @param [String] newPath\n        */\n        function (oldPath, newPath) {\n            fs.root.renameSync(normalizePath(oldPath), normalizePath(newPath));\n        };\n\n        fs.exists = /**\n        * Test whether or not the given path exists by checking with the file system.\n        * Then call the callback argument with either true or false.\n        * @example Sample invocation\n        *   fs.exists('/etc/passwd', function (exists) {\n        *     util.debug(exists ? \"it's there\" : \"no passwd!\");\n        *   });\n        * @param [String] path\n        * @param [Function(Boolean)] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                return fs.root.exists(normalizePath(path), newCb);\n            } catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return newCb(false);\n            }\n        };\n\n        fs.existsSync = /**\n        * Test whether or not the given path exists by checking with the file system.\n        * @param [String] path\n        * @return [boolean]\n        */\n        function (path) {\n            try  {\n                return fs.root.existsSync(normalizePath(path));\n            } catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return false;\n            }\n        };\n\n        fs.stat = /**\n        * Asynchronous `stat`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                return fs.root.stat(normalizePath(path), false, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        fs.statSync = /**\n        * Synchronous `stat`.\n        * @param [String] path\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        function (path) {\n            return fs.root.statSync(normalizePath(path), false);\n        };\n\n        fs.lstat = /**\n        * Asynchronous `lstat`.\n        * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n        * then the link itself is stat-ed, not the file that it refers to.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                return fs.root.stat(normalizePath(path), true, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        fs.lstatSync = /**\n        * Synchronous `lstat`.\n        * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n        * then the link itself is stat-ed, not the file that it refers to.\n        * @param [String] path\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        function (path) {\n            return fs.root.statSync(normalizePath(path), true);\n        };\n\n        fs.truncate = function (path, arg2, cb) {\n            if (typeof arg2 === \"undefined\") { arg2 = 0; }\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var len = 0;\n            if (typeof arg2 === 'function') {\n                cb = arg2;\n            } else if (typeof arg2 === 'number') {\n                len = arg2;\n            }\n\n            var newCb = wrapCb(cb, 1);\n            try  {\n                return fs.root.truncate(normalizePath(path), len, newCb);\n            } catch (e) {\n                return newCb(e);\n            }\n        };\n\n        fs.truncateSync = /**\n        * Synchronous `truncate`.\n        * @param [String] path\n        * @param [Number] len\n        */\n        function (path, len) {\n            if (typeof len === \"undefined\") { len = 0; }\n            return fs.root.truncateSync(normalizePath(path), len);\n        };\n\n        fs.unlink = /**\n        * Asynchronous `unlink`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                return fs.root.unlink(normalizePath(path), newCb);\n            } catch (e) {\n                return newCb(e);\n            }\n        };\n\n        fs.unlinkSync = /**\n        * Synchronous `unlink`.\n        * @param [String] path\n        */\n        function (path) {\n            return fs.root.unlinkSync(normalizePath(path));\n        };\n\n        fs.open = function (path, flag, arg2, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var mode = normalizeMode(arg2, 0x1a4);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            var newCb = wrapCb(cb, 2);\n            try  {\n                return fs.root.open(normalizePath(path), FileFlag.getFileFlag(flag), mode, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        fs.openSync = function (path, flag, mode) {\n            if (typeof mode === \"undefined\") { mode = 0x1a4; }\n            return fs.root.openSync(normalizePath(path), FileFlag.getFileFlag(flag), mode);\n        };\n\n        fs.readFile = function (filename, arg2, cb) {\n            if (typeof arg2 === \"undefined\") { arg2 = {}; }\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var options = normalizeOptions(arg2, null, 'r', null);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            var newCb = wrapCb(cb, 2);\n            try  {\n                var flag = FileFlag.getFileFlag(options['flag']);\n                if (!flag.isReadable()) {\n                    return newCb(new ApiError(ErrorType.INVALID_PARAM, 'Flag passed to readFile must allow for reading.'));\n                }\n                return fs.root.readFile(normalizePath(filename), options.encoding, flag, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        fs.readFileSync = function (filename, arg2) {\n            if (typeof arg2 === \"undefined\") { arg2 = {}; }\n            var options = normalizeOptions(arg2, null, 'r', null);\n            var flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isReadable()) {\n                throw new ApiError(ErrorType.INVALID_PARAM, 'Flag passed to readFile must allow for reading.');\n            }\n            return fs.root.readFileSync(normalizePath(filename), options.encoding, flag);\n        };\n\n        fs.writeFile = function (filename, data, arg3, cb) {\n            if (typeof arg3 === \"undefined\") { arg3 = {}; }\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                var flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isWriteable()) {\n                    return newCb(new ApiError(ErrorType.INVALID_PARAM, 'Flag passed to writeFile must allow for writing.'));\n                }\n                return fs.root.writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            } catch (e) {\n                return newCb(e);\n            }\n        };\n\n        fs.writeFileSync = function (filename, data, arg3) {\n            var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            var flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isWriteable()) {\n                throw new ApiError(ErrorType.INVALID_PARAM, 'Flag passed to writeFile must allow for writing.');\n            }\n            return fs.root.writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        };\n\n        fs.appendFile = function (filename, data, arg3, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                var flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isAppendable()) {\n                    return newCb(new ApiError(ErrorType.INVALID_PARAM, 'Flag passed to appendFile must allow for appending.'));\n                }\n                fs.root.appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.appendFileSync = function (filename, data, arg3) {\n            var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            var flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isAppendable()) {\n                throw new ApiError(ErrorType.INVALID_PARAM, 'Flag passed to appendFile must allow for appending.');\n            }\n            return fs.root.appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        };\n\n        fs.fstat = // FILE DESCRIPTOR METHODS\n        /**\n        * Asynchronous `fstat`.\n        * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n        * specified by the file descriptor `fd`.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] callback\n        */\n        function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                checkFd(fd);\n                fd.stat(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.fstatSync = /**\n        * Synchronous `fstat`.\n        * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n        * specified by the file descriptor `fd`.\n        * @param [BrowserFS.File] fd\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        function (fd) {\n            checkFd(fd);\n            return fd.statSync();\n        };\n\n        fs.close = /**\n        * Asynchronous close.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.close(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.closeSync = /**\n        * Synchronous close.\n        * @param [BrowserFS.File] fd\n        */\n        function (fd) {\n            checkFd(fd);\n            return fd.closeSync();\n        };\n\n        fs.ftruncate = function (fd, arg2, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var length = typeof arg2 === 'number' ? arg2 : 0;\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.truncate(length, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.ftruncateSync = /**\n        * Synchronous ftruncate.\n        * @param [BrowserFS.File] fd\n        * @param [Number] len\n        */\n        function (fd, len) {\n            if (typeof len === \"undefined\") { len = 0; }\n            checkFd(fd);\n            return fd.truncateSync(len);\n        };\n\n        fs.fsync = /**\n        * Asynchronous fsync.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.sync(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.fsyncSync = /**\n        * Synchronous fsync.\n        * @param [BrowserFS.File] fd\n        */\n        function (fd) {\n            checkFd(fd);\n            return fd.syncSync();\n        };\n\n        fs.fdatasync = /**\n        * Asynchronous fdatasync.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.datasync(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.fdatasyncSync = /**\n        * Synchronous fdatasync.\n        * @param [BrowserFS.File] fd\n        */\n        function (fd) {\n            checkFd(fd);\n            fd.datasyncSync();\n        };\n\n        fs.write = function (fd, arg2, arg3, arg4, arg5, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var buffer, offset, length, position = null;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\n                var encoding = 'utf8';\n                switch (typeof arg3) {\n                    case 'function':\n                        // (fd, string, cb)\n                        cb = arg3;\n                        break;\n                    case 'number':\n                        // (fd, string, position, encoding?, cb?)\n                        position = arg3;\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\n                        break;\n                    default:\n                        // ...try to find the callback and get out of here!\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n                        return cb(new ApiError(ErrorType.INVALID_PARAM, 'Invalid arguments.'));\n                }\n                buffer = new Buffer(arg2, encoding);\n                offset = 0;\n                length = buffer.length;\n            } else {\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n            }\n\n            var newCb = wrapCb(cb, 3);\n            try  {\n                checkFd(fd);\n                if (position == null) {\n                    position = fd.getPos();\n                }\n                fd.write(buffer, offset, length, position, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.writeSync = function (fd, arg2, arg3, arg4, arg5) {\n            var buffer, offset = 0, length, position;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]])\n                position = typeof arg3 === 'number' ? arg3 : null;\n                var encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                offset = 0;\n                buffer = new Buffer(arg2, encoding);\n                length = buffer.length;\n            } else {\n                // Signature 2: (fd, buffer, offset, length, position?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n            }\n\n            checkFd(fd);\n            if (position == null) {\n                position = fd.getPos();\n            }\n            return fd.writeSync(buffer, offset, length, position);\n        };\n\n        fs.read = function (fd, arg2, arg3, arg4, arg5, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var position, offset, length, buffer, newCb;\n            if (typeof arg2 === 'number') {\n                // legacy interface\n                // (fd, length, position, encoding, callback)\n                length = arg2;\n                position = arg3;\n                var encoding = arg4;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n                offset = 0;\n                buffer = new Buffer(length);\n\n                // XXX: Inefficient.\n                // Wrap the cb so we shelter upper layers of the API from these\n                // shenanigans.\n                newCb = wrapCb((function (err, bytesRead, buf) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb(err, buf.toString(encoding), bytesRead);\n                }), 3);\n            } else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n                newCb = wrapCb(cb, 3);\n            }\n\n            try  {\n                checkFd(fd);\n                if (position == null) {\n                    position = fd.getPos();\n                }\n                fd.read(buffer, offset, length, position, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.readSync = function (fd, arg2, arg3, arg4, arg5) {\n            var shenanigans = false;\n            var buffer, offset, length, position;\n            if (typeof arg2 === 'number') {\n                length = arg2;\n                position = arg3;\n                var encoding = arg4;\n                offset = 0;\n                buffer = new Buffer(length);\n                shenanigans = true;\n            } else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n            }\n            checkFd(fd);\n            if (position == null) {\n                position = fd.getPos();\n            }\n\n            var rv = fd.readSync(buffer, offset, length, position);\n            if (!shenanigans) {\n                return rv;\n            } else {\n                return [buffer.toString(encoding), rv];\n            }\n        };\n\n        fs.fchown = /**\n        * Asynchronous `fchown`.\n        * @param [BrowserFS.File] fd\n        * @param [Number] uid\n        * @param [Number] gid\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (fd, uid, gid, callback) {\n            if (typeof callback === \"undefined\") { callback = nopCb; }\n            var newCb = wrapCb(callback, 1);\n            try  {\n                checkFd(fd);\n                fd.chown(uid, gid, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.fchownSync = /**\n        * Synchronous `fchown`.\n        * @param [BrowserFS.File] fd\n        * @param [Number] uid\n        * @param [Number] gid\n        */\n        function (fd, uid, gid) {\n            checkFd(fd);\n            return fd.chownSync(uid, gid);\n        };\n\n        fs.fchmod = function (fd, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                checkFd(fd);\n                fd.chmod(mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.fchmodSync = function (fd, mode) {\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            checkFd(fd);\n            return fd.chmodSync(mode);\n        };\n\n        fs.futimes = function (fd, atime, mtime, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                fd.utimes(atime, mtime, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.futimesSync = function (fd, atime, mtime) {\n            checkFd(fd);\n            if (typeof atime === 'number') {\n                atime = new Date(atime * 1000);\n            }\n            if (typeof mtime === 'number') {\n                mtime = new Date(mtime * 1000);\n            }\n            return fd.utimesSync(atime, mtime);\n        };\n\n        fs.rmdir = // DIRECTORY-ONLY METHODS\n        /**\n        * Asynchronous `rmdir`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.rmdir(path, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.rmdirSync = /**\n        * Synchronous `rmdir`.\n        * @param [String] path\n        */\n        function (path) {\n            path = normalizePath(path);\n            return fs.root.rmdirSync(path);\n        };\n\n        fs.mkdir = /**\n        * Asynchronous `mkdir`.\n        * @param [String] path\n        * @param [Number?] mode defaults to `0777`\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (path, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            if (typeof mode === 'function') {\n                cb = mode;\n                mode = 0x1ff;\n            }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.mkdir(path, mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.mkdirSync = function (path, mode) {\n            if (typeof mode === \"undefined\") { mode = 0x1ff; }\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            path = normalizePath(path);\n            return fs.root.mkdirSync(path, mode);\n        };\n\n        fs.readdir = /**\n        * Asynchronous `readdir`. Reads the contents of a directory.\n        * The callback gets two arguments `(err, files)` where `files` is an array of\n        * the names of the files in the directory excluding `'.'` and `'..'`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, String[])] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                path = normalizePath(path);\n                fs.root.readdir(path, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.readdirSync = /**\n        * Synchronous `readdir`. Reads the contents of a directory.\n        * @param [String] path\n        * @return [String[]]\n        */\n        function (path) {\n            path = normalizePath(path);\n            return fs.root.readdirSync(path);\n        };\n\n        fs.link = // SYMLINK METHODS\n        /**\n        * Asynchronous `link`.\n        * @param [String] srcpath\n        * @param [String] dstpath\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (srcpath, dstpath, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                fs.root.link(srcpath, dstpath, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.linkSync = /**\n        * Synchronous `link`.\n        * @param [String] srcpath\n        * @param [String] dstpath\n        */\n        function (srcpath, dstpath) {\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return fs.root.linkSync(srcpath, dstpath);\n        };\n\n        fs.symlink = function (srcpath, dstpath, arg3, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var type = typeof arg3 === 'string' ? arg3 : 'file';\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                if (type !== 'file' && type !== 'dir') {\n                    return newCb(new ApiError(ErrorType.INVALID_PARAM, \"Invalid type: \" + type));\n                }\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                fs.root.symlink(srcpath, dstpath, type, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.symlinkSync = /**\n        * Synchronous `symlink`.\n        * @param [String] srcpath\n        * @param [String] dstpath\n        * @param [String?] type can be either `'dir'` or `'file'` (default is `'file'`)\n        */\n        function (srcpath, dstpath, type) {\n            if (type == null) {\n                type = 'file';\n            } else if (type !== 'file' && type !== 'dir') {\n                throw new ApiError(ErrorType.INVALID_PARAM, \"Invalid type: \" + type);\n            }\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return fs.root.symlinkSync(srcpath, dstpath, type);\n        };\n\n        fs.readlink = /**\n        * Asynchronous readlink.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, String)] callback\n        */\n        function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                path = normalizePath(path);\n                fs.root.readlink(path, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.readlinkSync = /**\n        * Synchronous readlink.\n        * @param [String] path\n        * @return [String]\n        */\n        function (path) {\n            path = normalizePath(path);\n            return fs.root.readlinkSync(path);\n        };\n\n        fs.chown = // PROPERTY OPERATIONS\n        /**\n        * Asynchronous `chown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (path, uid, gid, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.chown(path, false, uid, gid, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.chownSync = /**\n        * Synchronous `chown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        */\n        function (path, uid, gid) {\n            path = normalizePath(path);\n            fs.root.chownSync(path, false, uid, gid);\n        };\n\n        fs.lchown = /**\n        * Asynchronous `lchown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        function (path, uid, gid, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.chown(path, true, uid, gid, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.lchownSync = /**\n        * Synchronous `lchown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        */\n        function (path, uid, gid) {\n            path = normalizePath(path);\n            return fs.root.chownSync(path, true, uid, gid);\n        };\n\n        fs.chmod = function (path, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                path = normalizePath(path);\n                fs.root.chmod(path, false, mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.chmodSync = function (path, mode) {\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            path = normalizePath(path);\n            return fs.root.chmodSync(path, false, mode);\n        };\n\n        fs.lchmod = function (path, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                path = normalizePath(path);\n                fs.root.chmod(path, true, mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.lchmodSync = function (path, mode) {\n            path = normalizePath(path);\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            return fs.root.chmodSync(path, true, mode);\n        };\n\n        fs.utimes = function (path, atime, mtime, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                fs.root.utimes(path, atime, mtime, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.utimesSync = function (path, atime, mtime) {\n            path = normalizePath(path);\n            if (typeof atime === 'number') {\n                atime = new Date(atime * 1000);\n            }\n            if (typeof mtime === 'number') {\n                mtime = new Date(mtime * 1000);\n            }\n            return fs.root.utimesSync(path, atime, mtime);\n        };\n\n        fs.realpath = function (path, arg2, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var cache = typeof arg2 === 'object' ? arg2 : {};\n            cb = typeof arg2 === 'function' ? arg2 : nopCb;\n            var newCb = wrapCb(cb, 2);\n            try  {\n                path = normalizePath(path);\n                fs.root.realpath(path, cache, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.realpathSync = /**\n        * Synchronous `realpath`.\n        * @param [String] path\n        * @param [Object?] cache An object literal of mapped paths that can be used to\n        *   force a specific path resolution or avoid additional `fs.stat` calls for\n        *   known real paths.\n        * @return [String]\n        */\n        function (path, cache) {\n            if (typeof cache === \"undefined\") { cache = {}; }\n            path = normalizePath(path);\n            return fs.root.realpathSync(path, cache);\n        };\n        fs.root = null;\n        return fs;\n    })();\n    exports.fs = fs;\n});\n//# sourceMappingURL=node_fs.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('generic/preload_file',[\"require\", \"exports\", '../core/file', '../core/buffer', '../core/api_error', '../core/node_fs'], function(require, exports, __file__, __buffer__, __api_error__, __node_fs__) {\n    var file = __file__;\n    \n    \n    var buffer = __buffer__;\n    \n    var api_error = __api_error__;\n    var node_fs = __node_fs__;\n\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var fs = node_fs.fs;\n    var Buffer = buffer.Buffer;\n\n    /**\n    * An implementation of the File interface that operates on a file that is\n    * completely in-memory. PreloadFiles are backed by a Buffer.\n    *\n    * This is also an abstract class, as it lacks an implementation of 'sync' and\n    * 'close'. Each filesystem that wishes to use this file representation must\n    * extend this class and implement those two methods.\n    * @todo 'close' lever that disables functionality once closed.\n    */\n    var PreloadFile = (function (_super) {\n        __extends(PreloadFile, _super);\n        /**\n        * Creates a file with the given path and, optionally, the given contents. Note\n        * that, if contents is specified, it will be mutated by the file!\n        * @param [BrowserFS.FileSystem] _fs The file system that created the file.\n        * @param [String] _path\n        * @param [BrowserFS.FileMode] _mode The mode that the file was opened using.\n        *   Dictates permissions and where the file pointer starts.\n        * @param [BrowserFS.node.fs.Stats] _stat The stats object for the given file.\n        *   PreloadFile will mutate this object. Note that this object must contain\n        *   the appropriate mode that the file was opened as.\n        * @param [BrowserFS.node.Buffer?] contents A buffer containing the entire\n        *   contents of the file. PreloadFile will mutate this buffer. If not\n        *   specified, we assume it is a new file.\n        */\n        function PreloadFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this);\n            this._pos = 0;\n            this._fs = _fs;\n            this._path = _path;\n            this._flag = _flag;\n            this._stat = _stat;\n            if (contents != null) {\n                this._buffer = contents;\n            } else {\n                // Empty buffer. It'll expand once we write stuff to it.\n                this._buffer = new Buffer(0);\n            }\n\n            if (this._stat.size !== this._buffer.length) {\n                throw new Error(\"Invalid buffer: Buffer is \" + this._buffer.length + \" long, yet Stats object specifies that file is \" + this._stat.size + \" long.\");\n            }\n        }\n        /**\n        * Get the path to this file.\n        * @return [String] The path to the file.\n        */\n        PreloadFile.prototype.getPath = function () {\n            return this._path;\n        };\n\n        /**\n        * Get the current file position.\n        *\n        * We emulate the following bug mentioned in the Node documentation:\n        * > On Linux, positional writes don't work when the file is opened in append\n        *   mode. The kernel ignores the position argument and always appends the data\n        *   to the end of the file.\n        * @return [Number] The current file position.\n        */\n        PreloadFile.prototype.getPos = function () {\n            if (this._flag.isAppendable()) {\n                return this._stat.size;\n            }\n            return this._pos;\n        };\n\n        /**\n        * Advance the current file position by the indicated number of positions.\n        * @param [Number] delta\n        */\n        PreloadFile.prototype.advancePos = function (delta) {\n            return this._pos += delta;\n        };\n\n        /**\n        * Set the file position.\n        * @param [Number] newPos\n        */\n        PreloadFile.prototype.setPos = function (newPos) {\n            return this._pos = newPos;\n        };\n\n        /**\n        * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n        * class.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.sync = function (cb) {\n            try  {\n                this.syncSync();\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * **Core**: Synchronous sync.\n        */\n        PreloadFile.prototype.syncSync = function () {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n\n        /**\n        * **Core**: Asynchronous close. Must be implemented by subclasses of this\n        * class.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.close = function (cb) {\n            try  {\n                this.closeSync();\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * **Core**: Synchronous close.\n        */\n        PreloadFile.prototype.closeSync = function () {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n\n        /**\n        * Asynchronous `stat`.\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n        */\n        PreloadFile.prototype.stat = function (cb) {\n            try  {\n                cb(null, this._stat.clone());\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Synchronous `stat`.\n        */\n        PreloadFile.prototype.statSync = function () {\n            return this._stat.clone();\n        };\n\n        /**\n        * Asynchronous truncate.\n        * @param [Number] len\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.truncate = function (len, cb) {\n            try  {\n                this.truncateSync(len);\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\n                    this.sync(cb);\n                }\n                cb();\n            } catch (e) {\n                return cb(e);\n            }\n        };\n\n        /**\n        * Synchronous truncate.\n        * @param [Number] len\n        */\n        PreloadFile.prototype.truncateSync = function (len) {\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorType.PERMISSIONS_ERROR, 'File not opened with a writeable mode.');\n            }\n            this._stat.mtime = new Date();\n            if (len > this._buffer.length) {\n                var buf = new Buffer(len - this._buffer.length);\n                buf.fill(0);\n\n                // Write will set @_stat.size for us.\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                    this.syncSync();\n                }\n                return;\n            }\n            this._stat.size = len;\n\n            // Truncate buffer to 'len'.\n            var newBuff = new Buffer(len);\n            this._buffer.copy(newBuff, 0, 0, len);\n            this._buffer = newBuff;\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                this.syncSync();\n            }\n        };\n\n        /**\n        * Write buffer to the file.\n        * Note that it is unsafe to use fs.write multiple times on the same file\n        * without waiting for the callback.\n        * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n        *  the file.\n        * @param [Number] offset Offset in the buffer to start reading data from.\n        * @param [Number] length The amount of bytes to write to the file.\n        * @param [Number] position Offset from the beginning of the file where this\n        *   data should be written. If position is null, the data will be written at\n        *   the current position.\n        * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n        *   cb The number specifies the number of bytes written into the file.\n        */\n        PreloadFile.prototype.write = function (buffer, offset, length, position, cb) {\n            try  {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Write buffer to the file.\n        * Note that it is unsafe to use fs.writeSync multiple times on the same file\n        * without waiting for the callback.\n        * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n        *  the file.\n        * @param [Number] offset Offset in the buffer to start reading data from.\n        * @param [Number] length The amount of bytes to write to the file.\n        * @param [Number] position Offset from the beginning of the file where this\n        *   data should be written. If position is null, the data will be written at\n        *   the current position.\n        * @return [Number]\n        */\n        PreloadFile.prototype.writeSync = function (buffer, offset, length, position) {\n            if (position == null) {\n                position = this.getPos();\n            }\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorType.PERMISSIONS_ERROR, 'File not opened with a writeable mode.');\n            }\n            var endFp = position + length;\n            if (endFp > this._stat.size) {\n                this._stat.size = endFp;\n                if (endFp > this._buffer.length) {\n                    // Extend the buffer!\n                    var newBuff = new Buffer(endFp);\n                    this._buffer.copy(newBuff);\n                    this._buffer = newBuff;\n                }\n            }\n            var len = buffer.copy(this._buffer, position, offset, offset + length);\n            this._stat.mtime = new Date();\n            if (this._flag.isSynchronous()) {\n                this.syncSync();\n                return len;\n            }\n            this.setPos(position + len);\n            return len;\n        };\n\n        /**\n        * Read data from the file.\n        * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n        *   written to.\n        * @param [Number] offset The offset within the buffer where writing will\n        *   start.\n        * @param [Number] length An integer specifying the number of bytes to read.\n        * @param [Number] position An integer specifying where to begin reading from\n        *   in the file. If position is null, data will be read from the current file\n        *   position.\n        * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n        *   number is the number of bytes read\n        */\n        PreloadFile.prototype.read = function (buffer, offset, length, position, cb) {\n            try  {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Read data from the file.\n        * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n        *   written to.\n        * @param [Number] offset The offset within the buffer where writing will\n        *   start.\n        * @param [Number] length An integer specifying the number of bytes to read.\n        * @param [Number] position An integer specifying where to begin reading from\n        *   in the file. If position is null, data will be read from the current file\n        *   position.\n        * @return [Number]\n        */\n        PreloadFile.prototype.readSync = function (buffer, offset, length, position) {\n            if (!this._flag.isReadable()) {\n                throw new ApiError(ErrorType.PERMISSIONS_ERROR, 'File not opened with a readable mode.');\n            }\n            if (position == null) {\n                position = this.getPos();\n            }\n            var endRead = position + length;\n            if (endRead > this._stat.size) {\n                length = this._stat.size - position;\n            }\n            var rv = this._buffer.copy(buffer, offset, position, position + length);\n            this._stat.atime = new Date();\n            this._pos = position + length;\n            return rv;\n        };\n\n        /**\n        * Asynchronous `fchmod`.\n        * @param [Number|String] mode\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.chmod = function (mode, cb) {\n            try  {\n                this.chmodSync(mode);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Asynchronous `fchmod`.\n        * @param [Number] mode\n        */\n        PreloadFile.prototype.chmodSync = function (mode) {\n            if (!this._fs.supportsProps()) {\n                throw new ApiError(ErrorType.NOT_SUPPORTED);\n            }\n            this._stat.mode = mode;\n            this.syncSync();\n        };\n        return PreloadFile;\n    })(file.BaseFile);\n    exports.PreloadFile = PreloadFile;\n\n    /**\n    * File class for the InMemory and XHR file systems.\n    * Doesn't sync to anything, so it works nicely for memory-only files.\n    */\n    var NoSyncFile = (function (_super) {\n        __extends(NoSyncFile, _super);\n        function NoSyncFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        /**\n        * Asynchronous sync. Doesn't do anything, simply calls the cb.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        NoSyncFile.prototype.sync = function (cb) {\n            cb();\n        };\n\n        /**\n        * Synchronous sync. Doesn't do anything.\n        */\n        NoSyncFile.prototype.syncSync = function () {\n        };\n\n        /**\n        * Asynchronous close. Doesn't do anything, simply calls the cb.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        NoSyncFile.prototype.close = function (cb) {\n            cb();\n        };\n\n        /**\n        * Synchronous close. Doesn't do anything.\n        */\n        NoSyncFile.prototype.closeSync = function () {\n        };\n        return NoSyncFile;\n    })(PreloadFile);\n    exports.NoSyncFile = NoSyncFile;\n});\n//# sourceMappingURL=preload_file.js.map\n;","\ndefine('core/browserfs',[\"require\", \"exports\", './buffer', './node_fs', './node_path', './node_process'], function(require, exports, __buffer__, __node_fs__, __node_path__, __node_process__) {\n    var buffer = __buffer__;\n    var node_fs = __node_fs__;\n    var node_path = __node_path__;\n    var node_process = __node_process__;\n    \n\n    /**\n    * Installs BrowserFS onto the given object.\n    * We recommend that you run install with the 'window' object to make things\n    * global, as in Node.\n    *\n    * Properties installed:\n    *\n    * * Buffer\n    * * process\n    * * require (we monkey-patch it)\n    *\n    * This allows you to write code as if you were running inside Node.\n    * @param {object} obj - The object to install things onto (e.g. window)\n    */\n    function install(obj) {\n        obj.Buffer = buffer.Buffer;\n        obj.process = node_process.process;\n        var oldRequire = obj.require != null ? obj.require : null;\n\n        // Monkey-patch require for Node-style code.\n        obj.require = function (arg) {\n            var rv = exports.require(arg);\n            if (rv == null) {\n                return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));\n            } else {\n                return rv;\n            }\n        };\n    }\n    exports.install = install;\n\n    exports.FileSystem = {};\n    function registerFileSystem(name, fs) {\n        exports.FileSystem[name] = fs;\n    }\n    exports.registerFileSystem = registerFileSystem;\n\n    function require(module) {\n        switch (module) {\n            case 'fs':\n                return node_fs.fs;\n            case 'path':\n                return node_path.path;\n            case 'buffer':\n                return buffer.Buffer;\n            case 'process':\n                return node_process.process;\n            default:\n                return exports.FileSystem[module];\n        }\n    }\n    exports.require = require;\n\n    /**\n    * You must call this function with a properly-instantiated root file system\n    * before using any file system API method.\n    * @param {BrowserFS.FileSystem} rootFS - The root filesystem to use for the\n    *   entire BrowserFS file system.\n    */\n    function initialize(rootfs) {\n        return node_fs.fs._initialize(rootfs);\n    }\n    exports.initialize = initialize;\n});\n//# sourceMappingURL=browserfs.js.map\n;","\ndefine('core/file',[\"require\", \"exports\", './api_error'], function(require, exports, __api_error__) {\n    var api_error = __api_error__;\n    \n    \n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n\n    /**\n    * Base class that contains shared implementations of functions for the file\n    * object.\n    * @class\n    */\n    var BaseFile = (function () {\n        function BaseFile() {\n        }\n        BaseFile.prototype.sync = function (cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFile.prototype.syncSync = function () {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFile.prototype.datasync = function (cb) {\n            this.sync(cb);\n        };\n        BaseFile.prototype.datasyncSync = function () {\n            return this.syncSync();\n        };\n        BaseFile.prototype.chown = function (uid, gid, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFile.prototype.chownSync = function (uid, gid) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFile.prototype.chmod = function (mode, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFile.prototype.chmodSync = function (mode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFile.prototype.utimes = function (atime, mtime, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFile.prototype.utimesSync = function (atime, mtime) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        return BaseFile;\n    })();\n    exports.BaseFile = BaseFile;\n});\n//# sourceMappingURL=file.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/file_system',[\"require\", \"exports\", './api_error', './node_path', './node_fs', './buffer'], function(require, exports, __api_error__, __node_path__, __node_fs__, __buffer__) {\n    /**\n    * @module core/file_system\n    */\n    var api_error = __api_error__;\n    \n\n    \n    \n\n    var node_path = __node_path__;\n    var node_fs = __node_fs__;\n\n    var buffer = __buffer__;\n\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var path = node_path.path;\n    var fs = node_fs.fs;\n    var Buffer = buffer.Buffer;\n\n    /**\n    * Basic filesystem class. Most filesystems should extend this class, as it\n    * provides default implementations for a handful of methods.\n    */\n    var BaseFileSystem = (function () {\n        function BaseFileSystem() {\n        }\n        BaseFileSystem.prototype.supportsLinks = function () {\n            return false;\n        };\n        BaseFileSystem.prototype.diskSpace = function (p, cb) {\n            cb(0, 0);\n        };\n        BaseFileSystem.prototype.open = function (p, flag, mode, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.rename = function (oldPath, newPath, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.renameSync = function (oldPath, newPath) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.stat = function (p, isLstat, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.statSync = function (p, isLstat) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.openSync = function (p, flag, mode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.unlink = function (p, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.unlinkSync = function (p) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.rmdir = function (p, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.rmdirSync = function (p) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.mkdir = function (p, mode, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.mkdirSync = function (p, mode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.readdir = function (p, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.readdirSync = function (p) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.exists = function (p, cb) {\n            this.stat(p, null, function (err) {\n                cb(err == null);\n            });\n        };\n        BaseFileSystem.prototype.existsSync = function (p) {\n            try  {\n                this.statSync(p, true);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        };\n        BaseFileSystem.prototype.realpath = function (p, cache, cb) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                var splitPath = p.split(path.sep);\n\n                for (var i = 0; i < splitPath.length; i++) {\n                    var addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            } else {\n                // No symlinks. We just need to verify that it exists.\n                this.exists(p, function (doesExist) {\n                    if (doesExist) {\n                        cb(null, p);\n                    } else {\n                        cb(new ApiError(ErrorType.NOT_FOUND, \"File \" + p + \" not found.\"));\n                    }\n                });\n            }\n        };\n        BaseFileSystem.prototype.realpathSync = function (p, cache) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                var splitPath = p.split(path.sep);\n\n                for (var i = 0; i < splitPath.length; i++) {\n                    var addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            } else {\n                if (this.existsSync(p)) {\n                    return p;\n                } else {\n                    throw new ApiError(ErrorType.NOT_FOUND, \"File \" + p + \" not found.\");\n                }\n            }\n        };\n        BaseFileSystem.prototype.truncate = function (p, len, cb) {\n            fs.open(p, 'w', (function (er, fd) {\n                if (er) {\n                    return cb(er);\n                }\n                fs.ftruncate(fd, len, (function (er) {\n                    fs.close(fd, (function (er2) {\n                        cb(er || er2);\n                    }));\n                }));\n            }));\n        };\n        BaseFileSystem.prototype.truncateSync = function (p, len) {\n            var fd = fs.openSync(p, 'w');\n\n            try  {\n                fs.ftruncateSync(fd, len);\n            } catch (e) {\n                throw e;\n            } finally {\n                fs.closeSync(fd);\n            }\n        };\n        BaseFileSystem.prototype.readFile = function (fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            var oldCb = cb;\n\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (err == null) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                fs.fstat(fd, function (err, stat) {\n                    if (err != null) {\n                        return cb(err);\n                    }\n\n                    // Allocate buffer.\n                    var buf = new Buffer(stat.size);\n                    fs.read(fd, buf, 0, stat.size, 0, function (err) {\n                        if (err != null) {\n                            return cb(err);\n                        } else if (encoding === null) {\n                            return cb(err, buf);\n                        }\n                        try  {\n                            cb(null, buf.toString(encoding));\n                        } catch (e) {\n                            cb(e);\n                        }\n                    });\n                });\n            });\n        };\n        BaseFileSystem.prototype.readFileSync = function (fname, encoding, flag) {\n            // Get file.\n            var fd = this.openSync(fname, flag, 0x1a4);\n            try  {\n                var stat = fs.fstatSync(fd);\n\n                // Allocate buffer.\n                var buf = new Buffer(stat.size);\n                fs.readSync(fd, buf, 0, stat.size, 0);\n                fs.closeSync(fd);\n                if (encoding === null) {\n                    return buf;\n                }\n                return buf.toString(encoding);\n            } catch (e) {\n                fs.closeSync(fd);\n                throw e;\n            }\n        };\n        BaseFileSystem.prototype.writeFile = function (fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            var oldCb = cb;\n\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err != null) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err != null ? err : err2);\n                    });\n                };\n\n                try  {\n                    if (typeof data === 'string') {\n                        data = new Buffer(data, encoding);\n                    }\n                } catch (e) {\n                    return cb(e);\n                }\n\n                // Write into file.\n                fd.write(data, 0, data.length, 0, cb);\n            });\n        };\n        BaseFileSystem.prototype.writeFileSync = function (fname, data, encoding, flag, mode) {\n            // Get file.\n            var fd = this.openSync(fname, flag, mode);\n            try  {\n                if (typeof data === 'string') {\n                    data = new Buffer(data, encoding);\n                }\n\n                // Write into file.\n                fd.writeSync(data, 0, data.length, 0);\n            } finally {\n                fs.closeSync(fd);\n            }\n        };\n        BaseFileSystem.prototype.appendFile = function (fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            var oldCb = cb;\n            this.open(fname, flag, mode, function (err, fd) {\n                if (err != null) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err != null ? err : err2);\n                    });\n                };\n                if (typeof data === 'string') {\n                    data = new Buffer(data, encoding);\n                }\n                fd.write(data, 0, data.length, null, cb);\n            });\n        };\n        BaseFileSystem.prototype.appendFileSync = function (fname, data, encoding, flag, mode) {\n            var fd = this.openSync(fname, flag, mode);\n            try  {\n                if (typeof data === 'string') {\n                    data = new Buffer(data, encoding);\n                }\n                fd.writeSync(data, 0, data.length, null);\n            } finally {\n                fs.closeSync(fd);\n            }\n        };\n        BaseFileSystem.prototype.chmod = function (p, isLchmod, mode, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.chmodSync = function (p, isLchmod, mode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.chown = function (p, isLchown, uid, gid, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.chownSync = function (p, isLchown, uid, gid) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.utimes = function (p, atime, mtime, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.utimesSync = function (p, atime, mtime) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.link = function (srcpath, dstpath, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.linkSync = function (srcpath, dstpath) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.symlink = function (srcpath, dstpath, type, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.symlinkSync = function (srcpath, dstpath, type) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        BaseFileSystem.prototype.readlink = function (p, cb) {\n            cb(new ApiError(ErrorType.NOT_SUPPORTED));\n        };\n        BaseFileSystem.prototype.readlinkSync = function (p) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED);\n        };\n        return BaseFileSystem;\n    })();\n    exports.BaseFileSystem = BaseFileSystem;\n\n    /**\n    * Implements the asynchronous API in terms of the synchronous API.\n    * @class SynchronousFileSystem\n    */\n    var SynchronousFileSystem = (function (_super) {\n        __extends(SynchronousFileSystem, _super);\n        function SynchronousFileSystem() {\n            _super.apply(this, arguments);\n        }\n        SynchronousFileSystem.prototype.supportsSynch = function () {\n            return true;\n        };\n\n        SynchronousFileSystem.prototype.rename = function (oldPath, newPath, cb) {\n            try  {\n                this.renameSync(oldPath, newPath);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.stat = function (p, isLstat, cb) {\n            try  {\n                cb(null, this.statSync(p, isLstat));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.open = function (p, flags, mode, cb) {\n            try  {\n                cb(null, this.openSync(p, flags, mode));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.unlink = function (p, cb) {\n            try  {\n                this.unlinkSync(p);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.rmdir = function (p, cb) {\n            try  {\n                this.rmdirSync(p);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.mkdir = function (p, mode, cb) {\n            try  {\n                this.mkdirSync(p, mode);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.readdir = function (p, cb) {\n            try  {\n                cb(null, this.readdirSync(p));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.chmod = function (p, isLchmod, mode, cb) {\n            try  {\n                this.chmodSync(p, isLchmod, mode);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.chown = function (p, isLchown, uid, gid, cb) {\n            try  {\n                this.chownSync(p, isLchown, uid, gid);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.utimes = function (p, atime, mtime, cb) {\n            try  {\n                this.utimesSync(p, atime, mtime);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.link = function (srcpath, dstpath, cb) {\n            try  {\n                this.linkSync(srcpath, dstpath);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.symlink = function (srcpath, dstpath, type, cb) {\n            try  {\n                this.symlinkSync(srcpath, dstpath, type);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.readlink = function (p, cb) {\n            try  {\n                cb(null, this.readlinkSync(p));\n            } catch (e) {\n                cb(e);\n            }\n        };\n        return SynchronousFileSystem;\n    })(BaseFileSystem);\n    exports.SynchronousFileSystem = SynchronousFileSystem;\n});\n//# sourceMappingURL=file_system.js.map\n;","\ndefine('core/node_fs_stats',[\"require\", \"exports\"], function(require, exports) {\n    \n    \n\n    /**\n    * @class\n    */\n    (function (FileType) {\n        FileType[FileType[\"FILE\"] = 1] = \"FILE\";\n        FileType[FileType[\"DIRECTORY\"] = 2] = \"DIRECTORY\";\n        FileType[FileType[\"SYMLINK\"] = 3] = \"SYMLINK\";\n        FileType[FileType[\"SOCKET\"] = 4] = \"SOCKET\";\n    })(exports.FileType || (exports.FileType = {}));\n    var FileType = exports.FileType;\n\n    /**\n    * Emulation of Node's `fs.Stats` object.\n    *\n    * Attribute descriptions are from `man 2 stat'\n    * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\n    * @see http://man7.org/linux/man-pages/man2/stat.2.html\n    * @class\n    */\n    var Stats = (function () {\n        /**\n        * Provides information about a particular entry in the file system.\n        * @param [Number] item_type type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\n        * @param [Number] size Size of the item in bytes. For directories/symlinks,\n        *   this is normally the size of the struct that represents the item.\n        * @param [Number] mode Unix-style file mode (e.g. 0o644)\n        * @param [Date?] atime time of last access\n        * @param [Date?] mtime time of last modification\n        * @param [Date?] ctime time of creation\n        */\n        function Stats(item_type, size, mode, atime, mtime, ctime) {\n            if (typeof mode === \"undefined\") { mode = 0x1a4; }\n            if (typeof atime === \"undefined\") { atime = new Date(); }\n            if (typeof mtime === \"undefined\") { mtime = new Date(); }\n            if (typeof ctime === \"undefined\") { ctime = new Date(); }\n            this.item_type = item_type;\n            this.size = size;\n            this.mode = mode;\n            this.atime = atime;\n            this.mtime = mtime;\n            this.ctime = ctime;\n            /**\n            * UNSUPPORTED ATTRIBUTES\n            * I assume no one is going to need these details, although we could fake\n            * appropriate values if need be.\n            */\n            // ID of device containing file\n            this.dev = 0;\n            // inode number\n            this.ino = 0;\n            // device ID (if special file)\n            this.rdev = 0;\n            // number of hard links\n            this.nlink = 1;\n            // blocksize for file system I/O\n            this.blksize = 4096;\n            // @todo Maybe support these? atm, it's a one-user filesystem.\n            // user ID of owner\n            this.uid = 0;\n            // group ID of owner\n            this.gid = 0;\n            // number of 512B blocks allocated\n            this.blocks = Math.ceil(size / 512);\n\n            if (this.item_type === FileType.FILE) {\n                this.mode |= 0x8000;\n            } else {\n                this.mode |= 0x4000;\n            }\n        }\n        /**\n        * **Nonstandard**: Clone the stats object.\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        Stats.prototype.clone = function () {\n            return new Stats(this.item_type, this.size, this.mode, this.atime, this.mtime, this.ctime);\n        };\n\n        /**\n        * @return [Boolean] True if this item is a file.\n        */\n        Stats.prototype.isFile = function () {\n            return this.item_type === FileType.FILE;\n        };\n\n        /**\n        * @return [Boolean] True if this item is a directory.\n        */\n        Stats.prototype.isDirectory = function () {\n            return this.item_type === FileType.DIRECTORY;\n        };\n\n        /**\n        * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\n        */\n        Stats.prototype.isSymbolicLink = function () {\n            return this.item_type === FileType.SYMLINK;\n        };\n\n        /**\n        * @return [Boolean] True if this item is a socket\n        */\n        Stats.prototype.isSocket = function () {\n            return this.item_type === FileType.SOCKET;\n        };\n\n        /**\n        * Until a character/FIFO filesystem comes about, everything is block based.\n        * @return [Boolean] True; we currently only support block devices.\n        */\n        Stats.prototype.isBlockDevice = function () {\n            return true;\n        };\n\n        /**\n        * @return [Boolean] False; we currently only support block devices.\n        */\n        Stats.prototype.isCharacterDevice = function () {\n            return false;\n        };\n\n        /**\n        * @return [Boolean] False; we currently only support block devices.\n        */\n        Stats.prototype.isFIFO = function () {\n            return false;\n        };\n        return Stats;\n    })();\n    exports.Stats = Stats;\n});\n//# sourceMappingURL=node_fs_stats.js.map\n;","\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                setImmediate(fn);\n            };\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            var sync = true;\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        if (sync) {\n                            async.nextTick(iterate);\n                        }\n                        else {\n                            iterate();\n                        }\n                    }\n                }\n            });\n            sync = false;\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                if (err) {\n                    callback(err);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    async.nextTick(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.nextTick(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            var sync = true;\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                if (sync) {\n                    async.nextTick(function () {\n                        async.whilst(test, iterator, callback);\n                    });\n                }\n                else {\n                    async.whilst(test, iterator, callback);\n                }\n            });\n            sync = false;\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var sync = true;\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                if (sync) {\n                    async.nextTick(function () {\n                        async.doWhilst(iterator, test, callback);\n                    });\n                }\n                else {\n                    async.doWhilst(iterator, test, callback);\n                }\n            }\n            else {\n                callback();\n            }\n        });\n        sync = false;\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            var sync = true;\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                if (sync) {\n                    async.nextTick(function () {\n                        async.until(test, iterator, callback);\n                    });\n                }\n                else {\n                    async.until(test, iterator, callback);\n                }\n            });\n            sync = false;\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        var sync = true;\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                if (sync) {\n                    async.nextTick(function () {\n                        async.doUntil(iterator, test, callback);\n                    });\n                }\n                else {\n                    async.doUntil(iterator, test, callback);\n                }\n            }\n            else {\n                callback();\n            }\n        });\n        sync = false;\n    };\n\n    async.queue = function (worker, concurrency) {\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.nextTick(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var sync = true;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(function () {\n                        var cbArgs = arguments;\n\n                        if (sync) {\n                            async.nextTick(function () {\n                                next.apply(null, cbArgs);\n                            });\n                        } else {\n                            next.apply(null, arguments);\n                        }\n                    });\n                    worker(task.data, cb);\n                    sync = false;\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.nextTick(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define('backend/../../vendor/async/lib/async',[], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/dropbox',[\"require\", \"exports\", '../generic/preload_file', '../core/file_system', '../core/node_fs_stats', '../core/buffer', '../core/api_error', '../core/node_path', '../core/browserfs', \"../../vendor/async/lib/async\"], function(require, exports, __preload_file__, __file_system__, __node_fs_stats__, __buffer__, __api_error__, __node_path__, __browserfs__) {\n    /// <amd-dependency path=\"../../vendor/async/lib/async\" />\n    var preload_file = __preload_file__;\n    var file_system = __file_system__;\n    \n    var node_fs_stats = __node_fs_stats__;\n    var buffer = __buffer__;\n    var api_error = __api_error__;\n    \n    var node_path = __node_path__;\n    var browserfs = __browserfs__;\n    \n\n    var Buffer = buffer.Buffer;\n    var Stats = node_fs_stats.Stats;\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var path = node_path.path;\n    var FileType = node_fs_stats.FileType;\n\n    // The name `Dropbox` gets clobbered by the filesystem, so save a reference\n    // to the Dropbox.js client library\n    // @todo Don't do this.\n    window['db'] = window['Dropbox'];\n\n    // XXX: No typings available for the Dropbox client. :(\n    // XXX: The typings for async on DefinitelyTyped are out of date.\n    var async = require('../../vendor/async/lib/async');\n    var Buffer = buffer.Buffer;\n\n    var DropboxFile = (function (_super) {\n        __extends(DropboxFile, _super);\n        function DropboxFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        DropboxFile.prototype.sync = function (cb) {\n            (this._fs)._writeFileStrict(this._path, (this._buffer).buff.buffer, cb);\n        };\n\n        DropboxFile.prototype.close = function (cb) {\n            this.sync(cb);\n        };\n        return DropboxFile;\n    })(preload_file.PreloadFile);\n    exports.DropboxFile = DropboxFile;\n\n    var Dropbox = (function (_super) {\n        __extends(Dropbox, _super);\n        /**\n        * Arguments: an authenticated Dropbox.js client\n        */\n        function Dropbox(client) {\n            _super.call(this);\n            this.client = client;\n        }\n        Dropbox.prototype.getName = function () {\n            return 'Dropbox';\n        };\n\n        Dropbox.isAvailable = function () {\n            // Checks if the Dropbox library is loaded.\n            // @todo Check if the Dropbox library *can be used* in the current browser.\n            return typeof db !== 'undefined';\n        };\n\n        Dropbox.prototype.isReadOnly = function () {\n            return false;\n        };\n\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        Dropbox.prototype.supportsSymlinks = function () {\n            return false;\n        };\n\n        Dropbox.prototype.supportsProps = function () {\n            return false;\n        };\n\n        Dropbox.prototype.supportsSynch = function () {\n            return false;\n        };\n\n        Dropbox.prototype.empty = function (main_cb) {\n            var self = this;\n            self.client.readdir('/', function (error, paths, dir, files) {\n                if (error) {\n                    main_cb(error);\n                } else {\n                    var deleteFile = function (file, cb) {\n                        self.client.remove(file.path, function (err, stat) {\n                            cb(err);\n                        });\n                    };\n                    var finished = function (err) {\n                        if (err) {\n                            main_cb(err);\n                        } else {\n                            main_cb();\n                        }\n                    };\n                    async.each(files, deleteFile, finished);\n                }\n            });\n        };\n\n        Dropbox.prototype.rename = function (oldPath, newPath, cb) {\n            var self = this;\n            self.client.move(oldPath, newPath, function (error, stat) {\n                if (error) {\n                    self._sendError(cb, \"\" + oldPath + \" doesn't exist\");\n                } else {\n                    cb();\n                }\n            });\n        };\n\n        Dropbox.prototype.stat = function (path, isLstat, cb) {\n            var self = this;\n\n            // Ignore lstat case -- Dropbox doesn't support symlinks\n            // Stat the file\n            self.client.stat(path, function (error, stat) {\n                if (error || ((stat != null) && stat.isRemoved)) {\n                    return self._sendError(cb, \"\" + path + \" doesn't exist\");\n                } else {\n                    var stats = new Stats(self._statType(stat), stat.size);\n                    return cb(null, stats);\n                }\n            });\n        };\n\n        Dropbox.prototype.open = function (path, flags, mode, cb) {\n            var self = this, _this = this;\n\n            // Try and get the file's contents\n            self.client.readFile(path, {\n                arrayBuffer: true\n            }, function (error, content, db_stat, range) {\n                if (error) {\n                    if (flags.isReadable()) {\n                        return self._sendError(cb, \"\" + path + \" doesn't exist\");\n                    } else {\n                        switch (error.status) {\n                            case 0:\n                                return console.error('No connection');\n\n                            case 404:\n                                var ab = new ArrayBuffer(0);\n                                return self._writeFileStrict(path, ab, function (error2, stat) {\n                                    if (error2) {\n                                        self._sendError(cb, error2);\n                                    } else {\n                                        var file = self._makeFile(path, flags, stat, new Buffer(ab));\n                                        cb(null, file);\n                                    }\n                                });\n                            default:\n                                return console.log(\"Unhandled error: \" + error);\n                        }\n                    }\n                } else {\n                    // No error\n                    var buffer;\n\n                    if (content === null) {\n                        buffer = new Buffer(0);\n                    } else {\n                        buffer = new Buffer(content);\n                    }\n                    var file = self._makeFile(path, flags, db_stat, buffer);\n                    return cb(null, file);\n                }\n            });\n        };\n\n        Dropbox.prototype._writeFileStrict = function (p, data, cb) {\n            var self = this;\n            var parent = path.dirname(p);\n            self.stat(parent, false, function (error, stat) {\n                if (error) {\n                    self._sendError(cb, \"Can't create \" + p + \" because \" + parent + \" doesn't exist\");\n                } else {\n                    self.client.writeFile(p, data, function (error2, stat) {\n                        if (error2) {\n                            cb(error2);\n                        } else {\n                            cb(null, stat);\n                        }\n                    });\n                }\n            });\n        };\n\n        /**\n        * Private\n        * Returns a BrowserFS object representing the type of a Dropbox.js stat object\n        */\n        Dropbox.prototype._statType = function (stat) {\n            return stat.isFile ? FileType.FILE : FileType.DIRECTORY;\n        };\n\n        /**\n        * Private\n        * Returns a BrowserFS object representing a File, created from the data\n        * returned by calls to the Dropbox API.\n        */\n        Dropbox.prototype._makeFile = function (path, flag, stat, buffer) {\n            var type = this._statType(stat);\n            var stats = new Stats(type, stat.size);\n            return new DropboxFile(this, path, flag, stats, buffer);\n        };\n\n        /**\n        * Private\n        * Delete a file or directory from Dropbox\n        * isFile should reflect which call was made to remove the it (`unlink` or\n        * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n        * returned\n        */\n        Dropbox.prototype._remove = function (path, cb, isFile) {\n            var self = this;\n            self.client.stat(path, function (error, stat) {\n                var message = null;\n                if (error) {\n                    self._sendError(cb, \"\" + path + \" doesn't exist\");\n                } else {\n                    if (stat.isFile && !isFile) {\n                        self._sendError(cb, \"Can't remove \" + path + \" with rmdir -- it's a file, not a directory. Use `unlink` instead.\");\n                    } else if (!stat.isFile && isFile) {\n                        self._sendError(cb, \"Can't remove \" + path + \" with unlink -- it's a directory, not a file. Use `rmdir` instead.\");\n                    } else {\n                        self.client.remove(path, function (error, stat) {\n                            if (error) {\n                                self._sendError(cb, \"Failed to remove \" + path);\n                            } else {\n                                cb(null);\n                            }\n                        });\n                    }\n                }\n            });\n        };\n\n        /**\n        * Private\n        * Create a BrowserFS error object with message msg and pass it to cb\n        */\n        Dropbox.prototype._sendError = function (cb, msg) {\n            cb(new ApiError(ErrorType.INVALID_PARAM, msg));\n        };\n\n        /**\n        * Delete a file\n        */\n        Dropbox.prototype.unlink = function (path, cb) {\n            this._remove(path, cb, true);\n        };\n\n        /**\n        * Delete a directory\n        */\n        Dropbox.prototype.rmdir = function (path, cb) {\n            this._remove(path, cb, false);\n        };\n\n        /**\n        * Create a directory\n        */\n        Dropbox.prototype.mkdir = function (p, mode, cb) {\n            // Dropbox.js' client.mkdir() behaves like `mkdir -p`, i.e. it creates a\n            // directory and all its ancestors if they don't exist.\n            // Node's fs.mkdir() behaves like `mkdir`, i.e. it throws an error if an attempt\n            // is made to create a directory without a parent.\n            // To handle this inconsistency, a check for the existence of `path`'s parent\n            // must be performed before it is created, and an error thrown if it does\n            // not exist\n            var self = this;\n            var parent = path.dirname(p);\n            self.client.stat(parent, function (error, stat) {\n                if (error) {\n                    self._sendError(cb, \"Can't create \" + p + \" because \" + parent + \" doesn't exist\");\n                } else {\n                    self.client.mkdir(p, function (error, stat) {\n                        if (error) {\n                            self._sendError(cb, \"\" + p + \" already exists\");\n                        } else {\n                            cb(null);\n                        }\n                    });\n                }\n            });\n        };\n\n        /**\n        * Get the names of the files in a directory\n        */\n        Dropbox.prototype.readdir = function (path, cb) {\n            this.client.readdir(path, function (error, files, dir_stat, content_stats) {\n                if (error) {\n                    return cb(error);\n                } else {\n                    return cb(null, files);\n                }\n            });\n        };\n        return Dropbox;\n    })(file_system.BaseFileSystem);\n    exports.Dropbox = Dropbox;\n\n    browserfs.registerFileSystem('Dropbox', Dropbox);\n});\n//# sourceMappingURL=dropbox.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/html5fs',[\"require\", \"exports\", '../generic/preload_file', '../core/file_system', '../core/api_error', '../core/file_flag', '../core/node_fs_stats', '../core/buffer', '../core/browserfs', \"../../vendor/async/lib/async\"], function(require, exports, __preload_file__, __file_system__, __api_error__, __file_flag__, __node_fs_stats__, __buffer__, __browserfs__) {\n    /// <reference path=\"../../vendor/DefinitelyTyped/filesystem/filesystem.d.ts\" />\n    /// <amd-dependency path=\"../../vendor/async/lib/async\" />\n    var preload_file = __preload_file__;\n    var file_system = __file_system__;\n    var api_error = __api_error__;\n    var file_flag = __file_flag__;\n    var node_fs_stats = __node_fs_stats__;\n    var buffer = __buffer__;\n    \n    var browserfs = __browserfs__;\n    \n\n    var Buffer = buffer.Buffer;\n    var Stats = node_fs_stats.Stats;\n    var FileType = node_fs_stats.FileType;\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var ActionType = file_flag.ActionType;\n\n    // XXX: The typings for async on DefinitelyTyped are out of date.\n    var async = require('../../vendor/async/lib/async');\n\n    var _getFS = window.webkitRequestFileSystem || window.requestFileSystem || null;\n\n    function _requestQuota(type, size, success, errorCallback) {\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case window.PERSISTENT:\n                    (navigator).webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case window.TEMPORARY:\n                    (navigator).webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    // TODO: Figure out how to construct a DOMException/DOMError.\n                    errorCallback(null);\n                    break;\n            }\n        } else {\n            (window).webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n\n    // A note about getFile and getDirectory options:\n    // These methods are called at numerous places in this file, and are passed\n    // some combination of these two options:\n    //   - create: If true, the entry will be created if it doesn't exist.\n    //             If false, an error will be thrown if it doesn't exist.\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\n    //                and throw an error if it does.\n    var HTML5FSFile = (function (_super) {\n        __extends(HTML5FSFile, _super);\n        function HTML5FSFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        HTML5FSFile.prototype.sync = function (cb) {\n            var self = this;\n\n            // Don't create the file (it should already have been created by `open`)\n            var opts = {\n                create: false\n            };\n            var _fs = this._fs;\n            var success = function (entry) {\n                entry.createWriter(function (writer) {\n                    var blob = new Blob([(self._buffer).buff]);\n                    var length = blob.size;\n                    writer.onwriteend = function (event) {\n                        writer.onwriteend = null;\n                        writer.truncate(length);\n                        cb();\n                    };\n                    writer.onerror = function (err) {\n                        _fs._sendError(cb, 'Write failed');\n                    };\n                    writer.write(blob);\n                });\n            };\n            var error = function (err) {\n                _fs._sendError(cb, err);\n            };\n            _fs.fs.root.getFile(this._path, opts, success, error);\n        };\n\n        HTML5FSFile.prototype.close = function (cb) {\n            this.sync(cb);\n        };\n        return HTML5FSFile;\n    })(preload_file.PreloadFile);\n    exports.HTML5FSFile = HTML5FSFile;\n\n    var HTML5FS = (function (_super) {\n        __extends(HTML5FS, _super);\n        /**\n        * Arguments:\n        *   - type: PERSISTENT or TEMPORARY\n        *   - size: storage quota to request, in megabytes. Allocated value may be less.\n        */\n        function HTML5FS(size, type) {\n            _super.call(this);\n            this.size = size != null ? size : 5;\n            this.type = type != null ? type : window.PERSISTENT;\n            var kb = 1024;\n            var mb = kb * kb;\n            this.size *= mb;\n        }\n        HTML5FS.prototype.getName = function () {\n            return 'HTML5 FileSystem';\n        };\n\n        HTML5FS.isAvailable = function () {\n            return _getFS != null;\n        };\n\n        HTML5FS.prototype.isReadOnly = function () {\n            return false;\n        };\n\n        HTML5FS.prototype.supportsSymlinks = function () {\n            return false;\n        };\n\n        HTML5FS.prototype.supportsProps = function () {\n            return false;\n        };\n\n        HTML5FS.prototype.supportsSynch = function () {\n            return false;\n        };\n\n        /**\n        * Private\n        * Returns a human-readable error message for the given DOMError\n        * Full list of values here:\n        * https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n        * I've only implemented the most obvious ones, but more can be added to\n        * make errors more descriptive in the future.\n        */\n        HTML5FS.prototype._humanise = function (err) {\n            switch (err.code) {\n                case DOMException.QUOTA_EXCEEDED_ERR:\n                    return 'Filesystem full. Please delete some files to free up space.';\n                case DOMException.NOT_FOUND_ERR:\n                    return 'File does not exist.';\n                case DOMException.SECURITY_ERR:\n                    return 'Insecure file access.';\n                default:\n                    return \"Unknown Error: \" + err.name;\n            }\n        };\n\n        /**\n        * Nonstandard\n        * Requests a storage quota from the browser to back this FS.\n        */\n        HTML5FS.prototype.allocate = function (cb) {\n            if (typeof cb === \"undefined\") { cb = function () {\n            }; }\n            var self = this;\n            var success = function (fs) {\n                self.fs = fs;\n                cb();\n            };\n            var error = function (err) {\n                var msg = self._humanise(err);\n                console.error(\"Failed to create FS\");\n                console.error(msg);\n                self._sendError(cb, err);\n            };\n            if (this.type === window.PERSISTENT) {\n                _requestQuota(this.type, this.size, function (granted) {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            } else {\n                _getFS(this.type, this.size, success, error);\n            }\n        };\n\n        /**\n        * Nonstandard\n        * Deletes everything in the FS. Used for testing.\n        * Karma clears the storage after you quit it but not between runs of the test\n        * suite, and the tests expect an empty FS every time.\n        */\n        HTML5FS.prototype.empty = function (main_cb) {\n            var self = this;\n\n            // Get a list of all entries in the root directory to delete them\n            self._readdir('/', function (err, entries) {\n                if (err) {\n                    console.error('Failed to empty FS');\n                    main_cb(err);\n                } else {\n                    // Called when every entry has been operated on\n                    var finished = function (er) {\n                        if (err) {\n                            console.error(\"Failed to empty FS\");\n                            main_cb(err);\n                        } else {\n                            main_cb();\n                        }\n                    };\n\n                    // Removes files and recursively removes directories\n                    var deleteEntry = function (entry, cb) {\n                        var succ = function () {\n                            cb();\n                        };\n                        var error = function () {\n                            self._sendError(cb, \"Failed to remove \" + entry.fullPath);\n                        };\n                        if (entry.isFile) {\n                            entry.remove(succ, error);\n                        } else {\n                            (entry).removeRecursively(succ, error);\n                        }\n                    };\n\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    async.each(entries, deleteEntry, finished);\n                }\n            });\n        };\n\n        HTML5FS.prototype.rename = function (oldPath, newPath, cb) {\n            var self = this;\n            var success = function (file) {\n                // XXX: Um, I don't think this quite works, since oldPath is a string.\n                // The spec says we need the DirectoryEntry corresponding to the file's\n                // parent directory.\n                file.moveTo((oldPath), newPath);\n                cb();\n            };\n            var error = function (err) {\n                self._sendError(cb, \"Could not rename \" + oldPath + \" to \" + newPath);\n            };\n            this.fs.root.getFile(oldPath, {}, success, error);\n        };\n\n        HTML5FS.prototype.stat = function (path, isLstat, cb) {\n            var self = this;\n\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            var opts = {\n                create: false\n            };\n\n            // Called when the path has been successfully loaded as a file.\n            var loadAsFile = function (entry) {\n                var fileFromEntry = function (file) {\n                    var stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n\n            // Called when the path has been successfully loaded as a directory.\n            var loadAsDir = function (dir) {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                var size = 4096;\n                var stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n\n            // Called when the path couldn't be opened as a directory or a file.\n            var failedToLoad = function (err) {\n                self._sendError(cb, \"Could not stat \" + path);\n            };\n\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            var failedToLoadAsFile = function () {\n                self.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        };\n\n        HTML5FS.prototype.open = function (path, flags, mode, cb) {\n            var self = this;\n            var opts = {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            };\n\n            // Type of err differs between getFile and file.\n            var error = function (err) {\n                self._sendError(cb, \"Could not open \" + path);\n            };\n            var success = function (entry) {\n                var success2 = function (file) {\n                    var reader = new FileReader();\n                    reader.onloadend = function (event) {\n                        var bfs_file = self._makeFile(path, flags, file, reader.result);\n                        cb(null, bfs_file);\n                    };\n                    reader.onerror = error;\n                    reader.readAsArrayBuffer(file);\n                };\n                entry.file(success2, error);\n            };\n            this.fs.root.getFile(path, opts, success, error);\n        };\n\n        /**\n        * Private\n        * Create a BrowserFS error object with message msg and pass it to cb\n        */\n        HTML5FS.prototype._sendError = function (cb, err) {\n            var msg = typeof err === 'string' ? err : this._humanise(err);\n            cb(new ApiError(ErrorType.INVALID_PARAM, msg));\n        };\n\n        /**\n        * Private\n        * Returns a BrowserFS object representing the type of a Dropbox.js stat object\n        */\n        HTML5FS.prototype._statType = function (stat) {\n            return stat.isFile ? FileType.FILE : FileType.DIRECTORY;\n        };\n\n        /**\n        * Private\n        * Returns a BrowserFS object representing a File, created from the data\n        * returned by calls to the Dropbox API.\n        */\n        HTML5FS.prototype._makeFile = function (path, flag, stat, data) {\n            if (typeof data === \"undefined\") { data = new ArrayBuffer(0); }\n            var stats = new Stats(FileType.FILE, stat.size);\n            var buffer = new Buffer(data);\n            return new HTML5FSFile(this, path, flag, stats, buffer);\n        };\n\n        /**\n        * Private\n        * Delete a file or directory from the file system\n        * isFile should reflect which call was made to remove the it (`unlink` or\n        * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n        * returned\n        */\n        HTML5FS.prototype._remove = function (path, cb, isFile) {\n            var self = this;\n            var success = function (entry) {\n                var succ = function () {\n                    cb();\n                };\n                var err = function () {\n                    self._sendError(cb, \"Failed to remove \" + path);\n                };\n                entry.remove(succ, err);\n            };\n            var error = function (err) {\n                self._sendError(cb, \"Failed to remove \" + path);\n            };\n\n            // Deleting the entry, so don't create it\n            var opts = {\n                create: false\n            };\n\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            } else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        };\n\n        HTML5FS.prototype.unlink = function (path, cb) {\n            this._remove(path, cb, true);\n        };\n\n        HTML5FS.prototype.rmdir = function (path, cb) {\n            this._remove(path, cb, false);\n        };\n\n        HTML5FS.prototype.mkdir = function (path, mode, cb) {\n            var self = this;\n\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            var opts = {\n                create: true,\n                exclusive: true\n            };\n            var success = function (dir) {\n                cb();\n            };\n            var error = function (err) {\n                self._sendError(cb, \"Could not create directory: \" + path);\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        };\n\n        /**\n        * Private\n        * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n        */\n        HTML5FS.prototype._readdir = function (path, cb) {\n            var self = this;\n            var reader = this.fs.root.createReader();\n            var entries = [];\n            var error = function (err) {\n                self._sendError(cb, err);\n            };\n\n            // Call the reader.readEntries() until no more results are returned.\n            var readEntries = function () {\n                reader.readEntries((function (results) {\n                    if (results.length) {\n                        entries = entries.concat(_toArray(results));\n                        readEntries();\n                    } else {\n                        cb(null, entries);\n                    }\n                }), error);\n            };\n            readEntries();\n        };\n\n        /**\n        * Map _readdir's list of `FileEntry`s to their names and return that.\n        */\n        HTML5FS.prototype.readdir = function (path, cb) {\n            this._readdir(path, function (e, entries) {\n                if (e != null) {\n                    return cb(e);\n                }\n                var rv = [];\n                for (var i = 0; i < entries.length; i++) {\n                    rv.push(entries[i].name);\n                }\n                cb(null, rv);\n            });\n        };\n        return HTML5FS;\n    })(file_system.BaseFileSystem);\n    exports.HTML5FS = HTML5FS;\n\n    browserfs.registerFileSystem('HTML5FS', HTML5FS);\n});\n//# sourceMappingURL=html5fs.js.map\n;","\ndefine('generic/file_index',[\"require\", \"exports\", '../core/node_fs_stats', '../core/node_path'], function(require, exports, __node_fs_stats__, __node_path__) {\n    var node_fs_stats = __node_fs_stats__;\n    var node_path = __node_path__;\n\n    var Stats = node_fs_stats.Stats;\n    var path = node_path.path;\n\n    /**\n    * A simple class for storing a filesystem index. Assumes that all paths passed\n    * to it are *absolute* paths.\n    *\n    * Can be used as a partial or a full index, although care must be taken if used\n    * for the former purpose, especially when directories are concerned.\n    */\n    var FileIndex = (function () {\n        /**\n        * Constructs a new FileIndex.\n        */\n        function FileIndex() {\n            // _index is a single-level key,value store that maps *directory* paths to\n            // DirInodes. File information is only contained in DirInodes themselves.\n            this._index = {};\n        }\n        /**\n        * Split into a (directory path, item name) pair\n        */\n        FileIndex.prototype._split_path = function (p) {\n            var dirpath = path.dirname(p);\n            var itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\n            return [dirpath, itemname];\n        };\n\n        /**\n        * Adds the given absolute path to the index if it is not already in the index.\n        * Creates any needed parent directories.\n        * @param [String] path The path to add to the index.\n        * @param [BrowserFS.FileInode | BrowserFS.DirInode] inode The inode for the\n        *   path to add.\n        * @return [Boolean] 'True' if it was added or already exists, 'false' if there\n        *   was an issue adding it (e.g. item in path is a file, item exists but is\n        *   different).\n        * @todo If adding fails and implicitly creates directories, we do not clean up\n        *   the new empty directories.\n        */\n        FileIndex.prototype.addPath = function (path, inode) {\n            if (inode == null) {\n                throw new Error('Inode must be specified');\n            }\n            if (path[0] !== '/') {\n                throw new Error('Path must be absolute, got: ' + path);\n            }\n\n            if (this._index.hasOwnProperty(path)) {\n                return this._index[path] === inode;\n            }\n\n            var splitPath = this._split_path(path);\n            var dirpath = splitPath[0];\n            var itemname = splitPath[1];\n\n            // Try to add to its parent directory first.\n            var parent = this._index[dirpath];\n            if (parent === undefined && path !== '/') {\n                // Create parent.\n                parent = new DirInode();\n                if (!this.addPath(dirpath, parent)) {\n                    return false;\n                }\n            }\n\n            if (path !== '/') {\n                if (!parent.addItem(itemname, inode)) {\n                    return false;\n                }\n            }\n\n            if (!inode.isFile()) {\n                this._index[path] = inode;\n            }\n            return true;\n        };\n\n        /**\n        * Removes the given path. Can be a file or a directory.\n        * @return [BrowserFS.FileInode | BrowserFS.DirInode | null] The removed item,\n        *   or null if it did not exist.\n        */\n        FileIndex.prototype.removePath = function (path) {\n            var splitPath = this._split_path(path);\n            var dirpath = splitPath[0];\n            var itemname = splitPath[1];\n\n            // Try to remove it from its parent directory first.\n            var parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n\n            // Remove myself from my parent.\n            var inode = parent.remItem(itemname);\n            if (inode === null) {\n                return null;\n            }\n\n            if (!inode.isFile()) {\n                delete this._index[path];\n            }\n            return inode;\n        };\n\n        /**\n        * Retrieves the directory listing of the given path.\n        * @return [String[]] An array of files in the given path, or 'null' if it does\n        *   not exist.\n        */\n        FileIndex.prototype.ls = function (path) {\n            var item = this._index[path];\n            if (item === undefined) {\n                return null;\n            }\n            return item.getListing();\n        };\n\n        /**\n        * Returns the inode of the given item.\n        * @param [String] path\n        * @return [BrowserFS.FileInode | BrowserFS.DirInode | null] Returns null if\n        *   the item does not exist.\n        */\n        FileIndex.prototype.getInode = function (path) {\n            var splitPath = this._split_path(path);\n            var dirpath = splitPath[0];\n            var itemname = splitPath[1];\n\n            // Retrieve from its parent directory.\n            var parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n\n            if (dirpath === path) {\n                return parent;\n            }\n            return parent.getItem(itemname);\n        };\n\n        FileIndex.from_listing = /**\n        * Static method for constructing indices from a JSON listing.\n        * @param [Object] listing Directory listing generated by tools/XHRIndexer.coffee\n        * @return [BrowserFS.FileIndex] A new FileIndex object.\n        */\n        function (listing) {\n            var idx = new FileIndex();\n\n            // Add a root DirNode.\n            var rootInode = new DirInode();\n            idx._index['/'] = rootInode;\n            var queue = [['', listing, rootInode]];\n            while (queue.length > 0) {\n                var inode;\n                var next = queue.pop();\n                var pwd = next[0];\n                var tree = next[1];\n                var parent = next[2];\n                for (var node in tree) {\n                    var children = tree[node];\n                    var name = \"\" + pwd + \"/\" + node;\n                    if (children != null) {\n                        idx._index[name] = inode = new DirInode();\n                        queue.push([name, children, inode]);\n                    } else {\n                        // This inode doesn't have correct size information, noted with -1.\n                        idx._index[name] = inode = new Stats(node_fs_stats.FileType.FILE, -1);\n                    }\n                    if (parent != null) {\n                        parent._ls[node] = inode;\n                    }\n                }\n            }\n            return idx;\n        };\n        return FileIndex;\n    })();\n    exports.FileIndex = FileIndex;\n\n    /**\n    * Inode for a directory. Currently only contains the directory listing.\n    */\n    var DirInode = (function () {\n        /**\n        * Constructs an inode for a directory.\n        */\n        function DirInode() {\n            this._ls = {};\n        }\n        DirInode.prototype.isFile = function () {\n            return false;\n        };\n        DirInode.prototype.isDirectory = function () {\n            return true;\n        };\n\n        /**\n        * Return a Stats object for this inode.\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        DirInode.prototype.getStats = function () {\n            return new Stats(node_fs_stats.FileType.DIRECTORY, 4096);\n        };\n\n        /**\n        * Returns the directory listing for this directory. Paths in the directory are\n        * relative to the directory's path.\n        * @return [String[]] The directory listing for this directory.\n        */\n        DirInode.prototype.getListing = function () {\n            return Object.keys(this._ls);\n        };\n\n        /**\n        * Returns the inode for the indicated item, or null if it does not exist.\n        * @param [String] p Name of item in this directory.\n        * @return [BrowserFS.FileInode | BrowserFS.DirInode | null]\n        */\n        DirInode.prototype.getItem = function (p) {\n            var _ref;\n            return (_ref = this._ls[p]) != null ? _ref : null;\n        };\n\n        /**\n        * Add the given item to the directory listing. Note that the given inode is\n        * not copied, and will be mutated by the DirInode if it is a DirInode.\n        * @param [String] p Item name to add to the directory listing.\n        * @param [BrowserFS.FileInode | BrowserFS.DirInode] inode The inode for the\n        *   item to add to the directory inode.\n        * @return [Boolean] True if it was added, false if it already existed.\n        */\n        DirInode.prototype.addItem = function (p, inode) {\n            if (p in this._ls) {\n                return false;\n            }\n            this._ls[p] = inode;\n            return true;\n        };\n\n        /**\n        * Removes the given item from the directory listing.\n        * @param [String] p Name of item to remove from the directory listing.\n        * @return [BrowserFS.FileInode | BrowserFS.DirInode | null] Returns the item\n        *   removed, or null if the item did not exist.\n        */\n        DirInode.prototype.remItem = function (p) {\n            var item = this._ls[p];\n            if (item === undefined) {\n                return null;\n            }\n            delete this._ls[p];\n            return item;\n        };\n        return DirInode;\n    })();\n    exports.DirInode = DirInode;\n});\n//# sourceMappingURL=file_index.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('generic/indexed_filesystem',[\"require\", \"exports\", '../core/file_system', './file_index', '../core/file_flag', '../core/node_fs_stats', '../core/api_error', '../core/node_path'], function(require, exports, __file_system__, __file_index__, __file_flag__, __node_fs_stats__, __api_error__, __node_path__) {\n    var file_system = __file_system__;\n    var file_index = __file_index__;\n    var file_flag = __file_flag__;\n    \n    var node_fs_stats = __node_fs_stats__;\n    var api_error = __api_error__;\n    var node_path = __node_path__;\n\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var ActionType = file_flag.ActionType;\n    var FileType = node_fs_stats.FileType;\n    var Stats = node_fs_stats.Stats;\n    var FileFlag = file_flag.FileFlag;\n    var path = node_path.path;\n    var DirInode = file_index.DirInode;\n\n    /**\n    * A simple filesystem base class that uses an in-memory FileIndex.\n    */\n    var IndexedFileSystem = (function (_super) {\n        __extends(IndexedFileSystem, _super);\n        /**\n        * Constructs the file system with the given FileIndex.\n        * @param [BrowserFS.FileIndex] _index\n        */\n        function IndexedFileSystem(_index) {\n            _super.call(this);\n            this._index = _index;\n        }\n        // File or directory operations\n        IndexedFileSystem.prototype.renameSync = function (oldPath, newPath) {\n            var oldInode = this._index.removePath(oldPath);\n            if (oldInode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + oldPath + \" not found.\");\n            }\n\n            // Remove the given path if it exists.\n            this._index.removePath(newPath);\n            this._index.addPath(newPath, oldInode);\n        };\n\n        IndexedFileSystem.prototype.statSync = function (path, isLstat) {\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            }\n\n            var stats = typeof inode['getStats'] === 'function' ? (inode).getStats() : inode;\n            return stats;\n        };\n\n        // File operations\n        IndexedFileSystem.prototype.openSync = function (p, flags, mode) {\n            // Check if the path exists, and is a file.\n            var inode = this._index.getInode(p);\n            if (inode !== null) {\n                if (!inode.isFile()) {\n                    throw new ApiError(ErrorType.NOT_FOUND, \"\" + p + \" is a directory.\");\n                } else {\n                    switch (flags.pathExistsAction()) {\n                        case ActionType.THROW_EXCEPTION:\n                            throw new ApiError(ErrorType.INVALID_PARAM, \"\" + p + \" already exists.\");\n                            break;\n                        case ActionType.TRUNCATE_FILE:\n                            return this._truncate(p, flags, inode);\n                        case ActionType.NOP:\n                            return this._fetch(p, flags, inode);\n                        default:\n                            throw new ApiError(ErrorType.INVALID_PARAM, 'Invalid FileFlag object.');\n                    }\n                }\n            } else {\n                switch (flags.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        // Ensure the parent exists!\n                        var parentPath = path.dirname(p);\n                        var parentInode = this._index.getInode(parentPath);\n                        if (parentInode === null || parentInode.isFile()) {\n                            throw new ApiError(ErrorType.INVALID_PARAM, \"\" + parentPath + \" doesn't exist.\");\n                        }\n                        inode = new Stats(FileType.FILE, 0, mode);\n                        return this._create(p, flags, inode);\n                    case ActionType.THROW_EXCEPTION:\n                        throw new ApiError(ErrorType.INVALID_PARAM, \"\" + p + \" doesn't exist.\");\n                        break;\n                    default:\n                        throw new ApiError(ErrorType.INVALID_PARAM, 'Invalid FileFlag object.');\n                }\n            }\n        };\n\n        // Directory operations\n        IndexedFileSystem.prototype.unlinkSync = function (path) {\n            // Check if it exists, and is a file.\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            } else if (!inode.isFile()) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is a directory, not a file.\");\n            }\n            this._index.removePath(path);\n        };\n\n        IndexedFileSystem.prototype.rmdirSync = function (path) {\n            // Check if it exists, and is a directory.\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            } else if (inode.isFile()) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is a file, not a directory.\");\n            }\n            this._index.removePath(path);\n            this._rmdirSync(path, inode);\n        };\n\n        IndexedFileSystem.prototype.mkdirSync = function (p, mode) {\n            // Check if it exists.\n            var inode = this._index.getInode(p);\n            if (inode !== null) {\n                throw new ApiError(ErrorType.INVALID_PARAM, \"\" + p + \" already exists.\");\n            }\n\n            // Check if it lives below an existing dir (that is, we can't mkdir -p).\n            var parent = path.dirname(p);\n            if (parent !== '/' && this._index.getInode(parent) === null) {\n                throw new ApiError(ErrorType.INVALID_PARAM, \"Can't create \" + p + \" because \" + parent + \" doesn't exist.\");\n            }\n            var success = this._index.addPath(p, new DirInode());\n            if (success) {\n                return;\n            }\n            throw new ApiError(ErrorType.INVALID_PARAM, \"Could not add \" + path + \" for some reason.\");\n        };\n\n        IndexedFileSystem.prototype.readdirSync = function (path) {\n            // Check if it exists.\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            } else if (inode.isFile()) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is a file, not a directory.\");\n            }\n            return (inode).getListing();\n        };\n\n        IndexedFileSystem.prototype.chmodSync = function (path, isLchmod, mode) {\n            var fd = this.openSync(path, FileFlag.getFileFlag('r+'), 0x1a4);\n            (fd)._stat.mode = mode;\n            fd.closeSync();\n        };\n\n        IndexedFileSystem.prototype.chownSync = function (path, isLchown, uid, gid) {\n            var fd = this.openSync(path, FileFlag.getFileFlag('r+'), 0x1a4);\n            (fd)._stat.uid = uid;\n            (fd)._stat.gid = gid;\n            fd.closeSync();\n        };\n\n        IndexedFileSystem.prototype.utimesSync = function (path, atime, mtime) {\n            var fd = this.openSync(path, FileFlag.getFileFlag('r+'), 0x1a4);\n            (fd)._stat.atime = atime;\n            (fd)._stat.mtime = mtime;\n            fd.closeSync();\n        };\n\n        IndexedFileSystem.prototype._rmdirSync = function (path, inode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, '_rmdirSync is not implemented.');\n        };\n        IndexedFileSystem.prototype._create = function (path, flag, inode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, '_create is not implemented.');\n        };\n        IndexedFileSystem.prototype._fetch = function (path, flag, inode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, '_fetch is not implemented.');\n        };\n        IndexedFileSystem.prototype._truncate = function (path, flag, inode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, '_truncate is not implemented.');\n        };\n        return IndexedFileSystem;\n    })(file_system.SynchronousFileSystem);\n    exports.IndexedFileSystem = IndexedFileSystem;\n});\n//# sourceMappingURL=indexed_filesystem.js.map\n;","\n/**\n* Grab bag of utility functions used across the code.\n*/\ndefine('core/util',[\"require\", \"exports\"], function(require, exports) {\n    /**\n    * Estimates the size of a JS object.\n    * @param {Object} object - the object to measure.\n    * @return {Number} estimated object size.\n    * @see http://stackoverflow.com/a/11900218/10601\n    */\n    function roughSizeOfObject(object) {\n        var bytes, key, objectList, prop, stack, value;\n        objectList = [];\n        stack = [object];\n        bytes = 0;\n        while (stack.length !== 0) {\n            value = stack.pop();\n            if (typeof value === 'boolean') {\n                bytes += 4;\n            } else if (typeof value === 'string') {\n                bytes += value.length * 2;\n            } else if (typeof value === 'number') {\n                bytes += 8;\n            } else if (typeof value === 'object' && objectList.indexOf(value) < 0) {\n                objectList.push(value);\n                bytes += 4;\n                for (key in value) {\n                    prop = value[key];\n                    bytes += key.length * 2;\n                    stack.push(prop);\n                }\n            }\n        }\n        return bytes;\n    }\n    exports.roughSizeOfObject = roughSizeOfObject;\n\n    exports.isIE = (/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) != null);\n});\n//# sourceMappingURL=util.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/in_memory',[\"require\", \"exports\", '../generic/indexed_filesystem', '../generic/file_index', '../core/buffer', '../generic/preload_file', '../core/util', '../core/browserfs'], function(require, exports, __indexed_filesystem__, __file_index__, __buffer__, __preload_file__, __util__, __browserfs__) {\n    var indexed_filesystem = __indexed_filesystem__;\n    var file_index = __file_index__;\n    \n    \n    \n    var buffer = __buffer__;\n    var preload_file = __preload_file__;\n    var util = __util__;\n    var browserfs = __browserfs__;\n    \n\n    var Buffer = buffer.Buffer;\n    var NoSyncFile = preload_file.NoSyncFile;\n\n    /**\n    * A simple filesystem that exists only in memory.\n    *\n    * Note: This hacks a file_data property into each file inode,\n    *   which are actually just fs.Stats objects.\n    */\n    var InMemory = (function (_super) {\n        __extends(InMemory, _super);\n        /**\n        * Constructs the file system, with no files or directories.\n        */\n        function InMemory() {\n            _super.call(this, new file_index.FileIndex());\n        }\n        /**\n        * Clears all data, resetting to the 'just-initialized' state.\n        */\n        InMemory.prototype.empty = function () {\n            this._index = new file_index.FileIndex();\n        };\n\n        InMemory.prototype.getName = function () {\n            return 'In-memory';\n        };\n\n        InMemory.isAvailable = function () {\n            return true;\n        };\n\n        /**\n        * Passes the size and taken space in bytes to the callback.\n        *\n        * **Note**: We can use all available memory on the system, so we return +Inf.\n        * @param [String] path Unused in the implementation.\n        * @param [Function(Number, Number)] cb\n        */\n        InMemory.prototype.diskSpace = function (path, cb) {\n            return cb(Infinity, util.roughSizeOfObject(this._index));\n        };\n\n        InMemory.prototype.isReadOnly = function () {\n            return false;\n        };\n\n        InMemory.prototype.supportsLinks = function () {\n            return false;\n        };\n\n        InMemory.prototype.supportsProps = function () {\n            return false;\n        };\n\n        InMemory.prototype._truncate = function (path, flags, inode) {\n            inode.size = 0;\n            inode.mtime = new Date();\n            var file = inode.file_data;\n            file._flag = flags;\n            file._buffer = new Buffer(0);\n            return file;\n        };\n\n        InMemory.prototype._fetch = function (path, flags, inode) {\n            var file = inode.file_data;\n            file._flag = flags;\n            return file;\n        };\n\n        InMemory.prototype._create = function (path, flags, inode) {\n            var file = new NoSyncFile(this, path, flags, inode);\n            inode.file_data = file;\n            this._index.addPath(path, inode);\n            return file;\n        };\n\n        InMemory.prototype._rmdirSync = function (path, inode) {\n        };\n        return InMemory;\n    })(indexed_filesystem.IndexedFileSystem);\n    exports.InMemory = InMemory;\n\n    browserfs.registerFileSystem('InMemory', InMemory);\n});\n//# sourceMappingURL=in_memory.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/localStorage',[\"require\", \"exports\", '../generic/indexed_filesystem', '../generic/preload_file', '../core/node_fs_stats', '../core/buffer', '../generic/file_index', '../core/string_util', '../core/api_error', '../core/node_path', '../core/browserfs'], function(require, exports, __indexed_filesystem__, __preload_file__, __node_fs_stats__, __buffer__, __file_index__, __string_util__, __api_error__, __node_path__, __browserfs__) {\n    var indexed_filesystem = __indexed_filesystem__;\n    var preload_file = __preload_file__;\n    var node_fs_stats = __node_fs_stats__;\n    \n    var buffer = __buffer__;\n    var file_index = __file_index__;\n    var string_util = __string_util__;\n    var api_error = __api_error__;\n    var node_path = __node_path__;\n    \n    var browserfs = __browserfs__;\n    \n\n    var Buffer = buffer.Buffer;\n    var Stats = node_fs_stats.Stats;\n    var FileType = node_fs_stats.FileType;\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var path = node_path.path;\n\n    /**\n    * A simple filesystem backed by local storage.\n    *\n    * Note that your program should only ever have one instance of this class.\n    * @todo Pack names efficiently: Convert to UTF-8, then convert to a packed\n    *   UTF-16 representation (each character is 2 bytes).\n    * @todo Store directory information explicitly. Could do something cool, like\n    *   have directory information contain the keys for each subitem, where the\n    *   key doesn't have to be the full-path. That would conserve space in\n    *   localStorage.\n    */\n    var LocalStorageAbstract = (function (_super) {\n        __extends(LocalStorageAbstract, _super);\n        /**\n        * Constructs the file system. Loads up any existing files stored in local\n        * storage into a simple file index.\n        */\n        function LocalStorageAbstract() {\n            _super.call(this, new file_index.FileIndex());\n            for (var i = 0; i < window.localStorage.length; i++) {\n                var path = window.localStorage.key(i);\n                if (path[0] !== '/') {\n                    continue;\n                }\n                var data = window.localStorage.getItem(path);\n                if (data == null) {\n                    // XXX: I don't know *how*, but sometimes these items become null.\n                    data = '';\n                }\n                var len = this._getFileLength(data);\n                var inode = new Stats(FileType.FILE, len);\n                this._index.addPath(path, inode);\n            }\n        }\n        /**\n        * Retrieve the indicated file from `localStorage`.\n        * @param [String] path\n        * @param [BrowserFS.FileMode] flags\n        * @param [BrowserFS.FileInode] inode\n        * @return [BrowserFS.File.PreloadFile] Returns a preload file with the file's\n        *   contents, or null if it does not exist.\n        */\n        LocalStorageAbstract.prototype._getFile = function (path, flags, inode) {\n            var data = window.localStorage.getItem(path);\n            if (data === null) {\n                return null;\n            }\n            return this._convertFromBinaryString(path, data, flags, inode);\n        };\n\n        /**\n        * Handles syncing file data with `localStorage`.\n        * @param [String] path\n        * @param [String] data\n        * @param [BrowserFS.FileInode] inode\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        LocalStorageAbstract.prototype._syncSync = function (path, data, inode) {\n            var dataStr = this._convertToBinaryString(data, inode);\n            try  {\n                window.localStorage.setItem(path, dataStr);\n                this._index.addPath(path, inode);\n            } catch (e) {\n                throw new ApiError(ErrorType.DRIVE_FULL, \"Unable to sync \" + path);\n            }\n        };\n\n        /**\n        * Removes all data from localStorage.\n        */\n        LocalStorageAbstract.prototype.empty = function () {\n            window.localStorage.clear();\n            this._index = new file_index.FileIndex();\n        };\n\n        LocalStorageAbstract.prototype.getName = function () {\n            return 'localStorage';\n        };\n\n        LocalStorageAbstract.isAvailable = function () {\n            return typeof window !== 'undefined' && window !== null && typeof window['localStorage'] !== 'undefined';\n        };\n\n        LocalStorageAbstract.prototype.diskSpace = function (path, cb) {\n            // Guesstimate (5MB)\n            var storageLimit = 5242880;\n\n            // Assume everything is stored as UTF-16 (2 bytes per character)\n            var usedSpace = 0;\n            for (var i = 0; i < window.localStorage.length; i++) {\n                var key = window.localStorage.key(i);\n                usedSpace += key.length * 2;\n                var data = window.localStorage.getItem(key);\n                usedSpace += data.length * 2;\n            }\n\n            if (typeof window.localStorage['remainingSpace'] !== 'undefined') {\n                var remaining = window.localStorage.remainingSpace;\n\n                // We can extract a more precise upper-limit from this.\n                storageLimit = usedSpace + remaining;\n            }\n            cb(storageLimit, usedSpace);\n        };\n\n        LocalStorageAbstract.prototype.isReadOnly = function () {\n            return false;\n        };\n\n        LocalStorageAbstract.prototype.supportsLinks = function () {\n            return false;\n        };\n\n        LocalStorageAbstract.prototype.supportsProps = function () {\n            return true;\n        };\n\n        LocalStorageAbstract.prototype.unlinkSync = function (path) {\n            _super.prototype.unlinkSync.call(this, path);\n            window.localStorage.removeItem(path);\n        };\n\n        LocalStorageAbstract.prototype._truncate = function (path, flags, inode) {\n            inode.size = 0;\n            return new LocalStorageFile(this, path, flags, inode);\n        };\n\n        LocalStorageAbstract.prototype._fetch = function (path, flags, inode) {\n            return this._getFile(path, flags, inode);\n        };\n\n        LocalStorageAbstract.prototype._create = function (path, flags, inode) {\n            return new LocalStorageFile(this, path, flags, inode);\n        };\n\n        LocalStorageAbstract.prototype._rmdirSync = function (p, inode) {\n            // Remove all files belonging to the path from `localStorage`.\n            var files = inode.getListing();\n            var sep = path.sep;\n            for (var i = 0; i < files.length; i++) {\n                var file = files[i];\n                window.localStorage.removeItem(\"\" + p + sep + file);\n            }\n        };\n\n        LocalStorageAbstract.prototype._convertToBinaryString = function (data, inode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, 'LocalStorageAbstract is an abstract class.');\n        };\n        LocalStorageAbstract.prototype._convertFromBinaryString = function (path, data, flags, inode) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, 'LocalStorageAbstract is an abstract class.');\n        };\n        LocalStorageAbstract.prototype._getFileLength = function (data) {\n            throw new ApiError(ErrorType.NOT_SUPPORTED, 'LocalStorageAbstract is an abstract class.');\n        };\n        return LocalStorageAbstract;\n    })(indexed_filesystem.IndexedFileSystem);\n    exports.LocalStorageAbstract = LocalStorageAbstract;\n\n    var LocalStorageModern = (function (_super) {\n        __extends(LocalStorageModern, _super);\n        function LocalStorageModern() {\n            _super.call(this);\n        }\n        LocalStorageModern.prototype._convertToBinaryString = function (data, inode) {\n            var dataStr = data.toString('binary_string');\n\n            // Append fixed-size header with mode (16-bits) and mtime/atime (64-bits each).\n            // I don't care about uid/gid right now.\n            // That amounts to 18 bytes/9 characters + 1 character header\n            var headerBuff = new Buffer(18);\n            headerBuff.writeUInt16BE(inode.mode, 0);\n\n            // Well, they're doubles and are going to be 64-bit regardless...\n            headerBuff.writeDoubleBE(inode.mtime.getTime(), 2);\n            headerBuff.writeDoubleBE(inode.atime.getTime(), 10);\n            var headerDat = headerBuff.toString('binary_string');\n            dataStr = headerDat + dataStr;\n            return dataStr;\n        };\n\n        LocalStorageModern.prototype._convertFromBinaryString = function (path, data, flags, inode) {\n            var headerBuff = new Buffer(data.substr(0, 10), 'binary_string');\n            data = data.substr(10);\n            var buffer = new Buffer(data, 'binary_string');\n            var file = new LocalStorageFile(this, path, flags, inode, buffer);\n            file._stat.mode = headerBuff.readUInt16BE(0);\n            file._stat.mtime = new Date(headerBuff.readDoubleBE(2));\n            file._stat.atime = new Date(headerBuff.readDoubleBE(10));\n            return file;\n        };\n\n        LocalStorageModern.prototype._getFileLength = function (data) {\n            if (data.length > 10) {\n                return string_util.FindUtil('binary_string').byteLength(data.substr(10));\n            } else {\n                return 0;\n            }\n        };\n        return LocalStorageModern;\n    })(LocalStorageAbstract);\n    exports.LocalStorageModern = LocalStorageModern;\n\n    var LocalStorageOld = (function (_super) {\n        __extends(LocalStorageOld, _super);\n        function LocalStorageOld() {\n            _super.call(this);\n        }\n        LocalStorageOld.prototype._convertToBinaryString = function (data, inode) {\n            var dataStr = data.toString('binary_string_ie');\n            var headerBuff = new Buffer(18);\n            headerBuff.writeUInt16BE(inode.mode, 0);\n\n            // Well, they're doubles and are going to be 64-bit regardless...\n            headerBuff.writeDoubleBE(inode.mtime.getTime(), 2);\n            headerBuff.writeDoubleBE(inode.atime.getTime(), 10);\n            var headerDat = headerBuff.toString('binary_string_ie');\n            dataStr = headerDat + dataStr;\n            return dataStr;\n        };\n\n        LocalStorageOld.prototype._convertFromBinaryString = function (path, data, flags, inode) {\n            var headerBuff = new Buffer(data.substr(0, 18), 'binary_string_ie');\n            data = data.substr(18);\n            var buffer = new Buffer(data, 'binary_string_ie');\n            var file = new LocalStorageFile(this, path, flags, inode, buffer);\n            file._stat.mode = headerBuff.readUInt16BE(0);\n            file._stat.mtime = new Date(headerBuff.readDoubleBE(2));\n            file._stat.atime = new Date(headerBuff.readDoubleBE(10));\n            return file;\n        };\n\n        LocalStorageOld.prototype._getFileLength = function (data) {\n            if (data.length > 0) {\n                return data.length - 18;\n            } else {\n                return 0;\n            }\n        };\n        return LocalStorageOld;\n    })(LocalStorageAbstract);\n    exports.LocalStorageOld = LocalStorageOld;\n\n    var LocalStorageFile = (function (_super) {\n        __extends(LocalStorageFile, _super);\n        function LocalStorageFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        LocalStorageFile.prototype.syncSync = function () {\n            (this._fs)._syncSync(this._path, this._buffer, this._stat);\n        };\n\n        LocalStorageFile.prototype.closeSync = function () {\n            this.syncSync();\n        };\n        return LocalStorageFile;\n    })(preload_file.PreloadFile);\n    exports.LocalStorageFile = LocalStorageFile;\n\n    // Some versions of FF and all versions of IE do not support the full range of\n    // 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.\n    // http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673\n    var supportsBinaryString = false;\n    try  {\n        window.localStorage.setItem(\"__test__\", String.fromCharCode(0xD800));\n        supportsBinaryString = window.localStorage.getItem(\"__test__\") === String.fromCharCode(0xD800);\n    } catch (e) {\n        // IE throws an exception.\n        supportsBinaryString = false;\n    }\n    exports.LocalStorage = supportsBinaryString ? LocalStorageModern : LocalStorageOld;\n\n    browserfs.registerFileSystem('LocalStorage', exports.LocalStorage);\n});\n//# sourceMappingURL=localStorage.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/mountable_file_system',[\"require\", \"exports\", '../core/file_system', './in_memory', '../core/api_error', '../core/node_fs', '../core/browserfs'], function(require, exports, __file_system__, __in_memory__, __api_error__, __node_fs__, __browserfs__) {\n    var file_system = __file_system__;\n    var in_memory = __in_memory__;\n    var api_error = __api_error__;\n    var node_fs = __node_fs__;\n    var browserfs = __browserfs__;\n\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var fs = node_fs.fs;\n\n    /**\n    * The MountableFileSystem allows you to mount multiple backend types or\n    * multiple instantiations of the same backend into a single file system tree.\n    * The file systems do not need to know about each other; all interactions are\n    * automatically facilitated through this interface.\n    *\n    * For example, if a file system is mounted at /mnt/blah, and a request came in\n    * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.\n    */\n    var MountableFileSystem = (function (_super) {\n        __extends(MountableFileSystem, _super);\n        function MountableFileSystem() {\n            _super.call(this);\n            this.mntMap = {};\n\n            // The InMemory file system serves purely to provide directory listings for\n            // mounted file systems.\n            this.rootFs = new in_memory.InMemory();\n        }\n        /**\n        * Mounts the file system at the given mount point.\n        */\n        MountableFileSystem.prototype.mount = function (mnt_pt, fs) {\n            if (this.mntMap[mnt_pt]) {\n                throw new ApiError(ErrorType.INVALID_PARAM, \"Mount point \" + mnt_pt + \" is already taken.\");\n            }\n\n            // @todo Ensure new mount path is not subsumed by active mount paths.\n            this.rootFs.mkdirSync(mnt_pt, 0x1ff);\n            this.mntMap[mnt_pt] = fs;\n        };\n\n        MountableFileSystem.prototype.umount = function (mnt_pt) {\n            if (!this.mntMap[mnt_pt]) {\n                throw new ApiError(ErrorType.INVALID_PARAM, \"Mount point \" + mnt_pt + \" is already unmounted.\");\n            }\n            delete this.mntMap[mnt_pt];\n            this.rootFs.rmdirSync(mnt_pt);\n        };\n\n        /**\n        * Returns the file system that the path points to.\n        */\n        MountableFileSystem.prototype._get_fs = function (path) {\n            for (var mnt_pt in this.mntMap) {\n                var fs = this.mntMap[mnt_pt];\n                if (path.indexOf(mnt_pt) === 0) {\n                    path = path.substr(mnt_pt.length > 1 ? mnt_pt.length : 0);\n                    if (path === '') {\n                        path = '/';\n                    }\n                    return { fs: fs, path: path };\n                }\n            }\n\n            // Query our root file system.\n            return { fs: this.rootFs, path: path };\n        };\n\n        // Global information methods\n        MountableFileSystem.prototype.getName = function () {\n            return 'MountableFileSystem';\n        };\n\n        MountableFileSystem.isAvailable = function () {\n            return true;\n        };\n\n        MountableFileSystem.prototype.diskSpace = function (path, cb) {\n            cb(0, 0);\n        };\n\n        MountableFileSystem.prototype.isReadOnly = function () {\n            return false;\n        };\n\n        MountableFileSystem.prototype.supportsLinks = function () {\n            // I'm not ready for cross-FS links yet.\n            return false;\n        };\n\n        MountableFileSystem.prototype.supportsProps = function () {\n            return false;\n        };\n\n        MountableFileSystem.prototype.supportsSynch = function () {\n            return true;\n        };\n\n        // The following methods involve multiple file systems, and thus have custom\n        // logic.\n        // Note that we go through the Node API to use its robust default argument\n        // processing.\n        MountableFileSystem.prototype.rename = function (oldPath, newPath, cb) {\n            // Scenario 1: old and new are on same FS.\n            var fs1_rv = this._get_fs(oldPath);\n            var fs2_rv = this._get_fs(newPath);\n            if (fs1_rv.fs === fs2_rv.fs) {\n                return fs1_rv.fs.rename(fs1_rv.path, fs2_rv.path, cb);\n            }\n\n            // Scenario 2: Different file systems.\n            // Read old file, write new file, delete old file.\n            return fs.readFile(oldPath, function (err, data) {\n                if (err) {\n                    return cb(err);\n                }\n                fs.writeFile(newPath, data, function (err) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    fs.unlink(oldPath, cb);\n                });\n            });\n        };\n\n        MountableFileSystem.prototype.renameSync = function (oldPath, newPath) {\n            // Scenario 1: old and new are on same FS.\n            var fs1_rv = this._get_fs(oldPath);\n            var fs2_rv = this._get_fs(newPath);\n            if (fs1_rv.fs === fs2_rv.fs) {\n                return fs1_rv.fs.renameSync(fs1_rv.path, fs2_rv.path);\n            }\n\n            // Scenario 2: Different file systems.\n            var data = fs.readFileSync(oldPath);\n            fs.writeFileSync(newPath, data);\n            return fs.unlinkSync(oldPath);\n        };\n        return MountableFileSystem;\n    })(file_system.BaseFileSystem);\n    exports.MountableFileSystem = MountableFileSystem;\n\n    /**\n    * Tricky: Define all of the functions that merely forward arguments to the\n    * relevant file system, or return/throw an error.\n    * Take advantage of the fact that the *first* argument is always the path, and\n    * the *last* is the callback function (if async).\n    */\n    function defineFcn(name, isSync, numArgs) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < (arguments.length - 0); _i++) {\n                args[_i] = arguments[_i + 0];\n            }\n            var rv = this._get_fs(args[0]);\n            args[0] = rv.path;\n            return rv.fs[name].apply(rv.fs, args);\n        };\n    }\n\n    var fsCmdMap = [\n        ['readdir', 'exists', 'unlink', 'rmdir', 'readlink'],\n        ['stat', 'mkdir', 'realpath', 'truncate'],\n        ['open', 'readFile', 'chmod', 'utimes'],\n        ['chown'],\n        ['writeFile', 'appendFile']\n    ];\n\n    for (var i = 0; i < fsCmdMap.length; i++) {\n        var cmds = fsCmdMap[i];\n        for (var j = 0; j < cmds.length; j++) {\n            var fnName = cmds[j];\n            MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);\n            MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);\n        }\n    }\n\n    browserfs.registerFileSystem('MountableFileSystem', MountableFileSystem);\n});\n//# sourceMappingURL=mountable_file_system.js.map\n;","\n/**\n* Contains utility methods for performing a variety of tasks with\n* XmlHttpRequest across browsers.\n*/\ndefine('generic/xhr',[\"require\", \"exports\", '../core/util', '../core/buffer', '../core/api_error'], function(require, exports, __util__, __buffer__, __api_error__) {\n    var util = __util__;\n    var buffer = __buffer__;\n    var api_error = __api_error__;\n\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var Buffer = buffer.Buffer;\n\n    function downloadFileIE(async, p, type, cb) {\n        switch (type) {\n            case 'buffer':\n\n            case 'json':\n                break;\n            default:\n                return cb(new ApiError(ErrorType.INVALID_PARAM, \"Invalid download type: \" + type));\n        }\n\n        var req = new XMLHttpRequest();\n        req.open('GET', p, async);\n        req.setRequestHeader(\"Accept-Charset\", \"x-user-defined\");\n        req.onreadystatechange = function (e) {\n            var data_array;\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            getIEByteArray(req.responseBody, data_array = []);\n                            return cb(null, new Buffer(data_array, true));\n                        case 'json':\n                            return cb(null, JSON.parse(req.responseText));\n                    }\n                } else {\n                    return cb(new ApiError(req.status, \"XHR error.\"));\n                }\n            }\n        };\n        req.send();\n    }\n\n    function asyncDownloadFileIE(p, type, cb) {\n        downloadFileIE(true, p, type, cb);\n    }\n\n    function syncDownloadFileIE(p, type) {\n        var rv;\n        downloadFileIE(false, p, type, function (err, data) {\n            if (err)\n                throw err;\n            rv = data;\n        });\n        return rv;\n    }\n\n    function asyncDownloadFileModern(p, type, cb) {\n        var req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        var jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                try  {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                } catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new ApiError(ErrorType.INVALID_PARAM, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, new Buffer(req.response ? req.response : 0));\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            } else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                } else {\n                    return cb(new ApiError(req.status, \"XHR error.\"));\n                }\n            }\n        };\n        req.send();\n    }\n\n    function syncDownloadFileModern(p, type) {\n        var req = new XMLHttpRequest();\n        req.open('GET', p, false);\n\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        var data = null;\n        var err = null;\n\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            var text = req.responseText;\n                            data = new Buffer(text.length);\n\n                            for (var i = 0; i < text.length; i++) {\n                                data.set(i, text.charCodeAt(i) & 0xff);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                } else {\n                    err = new ApiError(req.status, \"XHR error.\");\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n\n    function syncDownloadFileIE10(p, type) {\n        var req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                break;\n            default:\n                throw new ApiError(ErrorType.INVALID_PARAM, \"Invalid download type: \" + type);\n        }\n        var data;\n        var err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = new Buffer(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                } else {\n                    err = new ApiError(req.status, \"XHR error.\");\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n\n    function getFileSize(async, p, cb) {\n        var req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status == 200) {\n                    try  {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length'), 10));\n                    } catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new ApiError(ErrorType.NETWORK_ERROR, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                } else {\n                    return cb(new ApiError(req.status, \"XHR HEAD error.\"));\n                }\n            }\n        };\n        req.send();\n    }\n\n    /**\n    * Asynchronously download a file as a buffer or a JSON object.\n    * Note that the third function signature with a non-specialized type is\n    * invalid, but TypeScript requires it when you specialize string arguments to\n    * constants.\n    */\n    exports.asyncDownloadFile = (util.isIE && typeof Blob === 'undefined') ? asyncDownloadFileIE : asyncDownloadFileModern;\n\n    /**\n    * Synchronously download a file as a buffer or a JSON object.\n    * Note that the third function signature with a non-specialized type is\n    * invalid, but TypeScript requires it when you specialize string arguments to\n    * constants.\n    */\n    exports.syncDownloadFile = (util.isIE && typeof Blob === 'undefined') ? syncDownloadFileIE : (util.isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n\n    /**\n    * Synchronously retrieves the size of the given file in bytes.\n    */\n    function getFileSizeSync(p) {\n        var rv;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    exports.getFileSizeSync = getFileSizeSync;\n\n    /**\n    * Asynchronously retrieves the size of the given file in bytes.\n    */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n    exports.getFileSizeAsync = getFileSizeAsync;\n});\n//# sourceMappingURL=xhr.js.map\n;","\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/XmlHttpRequest',[\"require\", \"exports\", '../core/file_system', '../generic/file_index', '../core/buffer', '../core/api_error', '../core/file_flag', '../generic/preload_file', '../core/browserfs', '../generic/xhr'], function(require, exports, __file_system__, __file_index__, __buffer__, __api_error__, __file_flag__, __preload_file__, __browserfs__, __xhr__) {\n    var file_system = __file_system__;\n    var file_index = __file_index__;\n    var buffer = __buffer__;\n    var api_error = __api_error__;\n    var file_flag = __file_flag__;\n    \n    \n    \n    var preload_file = __preload_file__;\n    var browserfs = __browserfs__;\n    var xhr = __xhr__;\n\n    var Buffer = buffer.Buffer;\n    var ApiError = api_error.ApiError;\n    var ErrorType = api_error.ErrorType;\n    var FileFlag = file_flag.FileFlag;\n    var ActionType = file_flag.ActionType;\n\n    /**\n    * A simple filesystem backed by XmlHttpRequests.\n    */\n    var XmlHttpRequest = (function (_super) {\n        __extends(XmlHttpRequest, _super);\n        /**\n        * Constructs the file system.\n        * @param [String] listing_url The path to the JSON file index generated by\n        *   tools/XHRIndexer.coffee. This can be relative to the current webpage URL\n        *   or absolutely specified.\n        * @param [String] prefix_url The url prefix to use for all web-server requests.\n        */\n        function XmlHttpRequest(listing_url, prefix_url) {\n            _super.call(this);\n            if (listing_url == null) {\n                listing_url = 'index.json';\n            }\n            this.prefix_url = prefix_url != null ? prefix_url : '';\n            var listing = this._requestFileSync(listing_url, 'json');\n            if (listing == null) {\n                throw new Error(\"Unable to find listing at URL: \" + listing_url);\n            }\n            this._index = file_index.FileIndex.from_listing(listing);\n        }\n        XmlHttpRequest.prototype.empty = function () {\n            var idx = this._index._index;\n            for (var k in idx) {\n                var v = idx[k];\n                if (v.file_data != null) {\n                    v.file_data = null;\n                }\n            }\n        };\n\n        /**\n        * Only requests the HEAD content, for the file size.\n        */\n        XmlHttpRequest.prototype._requestFileSizeAsync = function (path, cb) {\n            xhr.getFileSizeAsync(this.prefix_url + path, cb);\n        };\n        XmlHttpRequest.prototype._requestFileSizeSync = function (path) {\n            return xhr.getFileSizeSync(this.prefix_url + path);\n        };\n\n        XmlHttpRequest.prototype._requestFileAsync = function (p, type, cb) {\n            xhr.asyncDownloadFile(this.prefix_url + p, type, cb);\n        };\n\n        XmlHttpRequest.prototype._requestFileSync = function (p, type) {\n            return xhr.syncDownloadFile(this.prefix_url + p, type);\n        };\n\n        XmlHttpRequest.prototype.getName = function () {\n            return 'XmlHttpRequest';\n        };\n\n        XmlHttpRequest.isAvailable = function () {\n            // @todo Older browsers use a different name for XHR, iirc.\n            return typeof XMLHttpRequest !== \"undefined\" && XMLHttpRequest !== null;\n        };\n\n        XmlHttpRequest.prototype.diskSpace = function (path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        };\n\n        XmlHttpRequest.prototype.isReadOnly = function () {\n            return true;\n        };\n\n        XmlHttpRequest.prototype.supportsLinks = function () {\n            return false;\n        };\n\n        XmlHttpRequest.prototype.supportsProps = function () {\n            return false;\n        };\n\n        XmlHttpRequest.prototype.supportsSynch = function () {\n            return true;\n        };\n\n        /**\n        * Special XHR function: Preload the given file into the index.\n        * @param [String] path\n        * @param [BrowserFS.Buffer] buffer\n        */\n        XmlHttpRequest.prototype.preloadFile = function (path, buffer) {\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            }\n            inode.size = buffer.length;\n            inode.file_data = new preload_file.NoSyncFile(this, path, FileFlag.getFileFlag('r'), inode, buffer);\n        };\n\n        XmlHttpRequest.prototype.stat = function (path, isLstat, cb) {\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\"));\n            }\n            var stats;\n            if (inode.isFile()) {\n                stats = inode;\n\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, stats);\n                    });\n                } else {\n                    cb(null, stats);\n                }\n            } else {\n                stats = (inode).getStats();\n                cb(null, stats);\n            }\n        };\n\n        XmlHttpRequest.prototype.statSync = function (path, isLstat) {\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            }\n            var stats;\n            if (inode.isFile()) {\n                stats = inode;\n\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            } else {\n                stats = (inode).getStats();\n            }\n            return stats;\n        };\n\n        XmlHttpRequest.prototype.open = function (path, flags, mode, cb) {\n            var _this = this;\n\n            // Check if the path exists, and is a file.\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is not in the FileIndex.\"));\n            }\n            if (inode.isDirectory()) {\n                return cb(new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is a directory.\"));\n            }\n            switch (flags.pathExistsAction()) {\n                case ActionType.THROW_EXCEPTION:\n                case ActionType.TRUNCATE_FILE:\n                    return cb(new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" already exists.\"));\n                case ActionType.NOP:\n                    if (inode.file_data != null) {\n                        return cb(null, inode.file_data);\n                    }\n\n                    // @todo be lazier about actually requesting the file\n                    this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                        if (err) {\n                            return cb(err);\n                        }\n\n                        // we don't initially have file sizes\n                        inode.size = buffer.length;\n                        inode.file_data = new preload_file.NoSyncFile(_this, path, flags, inode, buffer);\n                        return cb(null, inode.file_data);\n                    });\n                    break;\n                default:\n                    return cb(new ApiError(ErrorType.INVALID_PARAM, 'Invalid FileMode object.'));\n            }\n        };\n\n        XmlHttpRequest.prototype.openSync = function (path, flags, mode) {\n            // Check if the path exists, and is a file.\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is not in the FileIndex.\");\n            }\n            if (inode.isDirectory()) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is a directory.\");\n            }\n            switch (flags.pathExistsAction()) {\n                case ActionType.THROW_EXCEPTION:\n                case ActionType.TRUNCATE_FILE:\n                    throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" already exists.\");\n                case ActionType.NOP:\n                    if (inode.file_data != null) {\n                        return inode.file_data;\n                    }\n\n                    // @todo be lazier about actually requesting the file\n                    var buffer = this._requestFileSync(path, 'buffer');\n\n                    // we don't initially have file sizes\n                    inode.size = buffer.length;\n                    inode.file_data = new preload_file.NoSyncFile(this, path, flags, inode, buffer);\n                    return inode.file_data;\n                default:\n                    throw new ApiError(ErrorType.INVALID_PARAM, 'Invalid FileMode object.');\n            }\n        };\n\n        XmlHttpRequest.prototype.readdir = function (path, cb) {\n            try  {\n                cb(null, this.readdirSync(path));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        XmlHttpRequest.prototype.readdirSync = function (path) {\n            // Check if it exists.\n            var inode = this._index.getInode(path);\n            if (inode === null) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" not found.\");\n            } else if (inode.isFile()) {\n                throw new ApiError(ErrorType.NOT_FOUND, \"\" + path + \" is a file, not a directory.\");\n            }\n            return (inode).getListing();\n        };\n        return XmlHttpRequest;\n    })(file_system.BaseFileSystem);\n    exports.XmlHttpRequest = XmlHttpRequest;\n\n    browserfs.registerFileSystem('XmlHttpRequest', XmlHttpRequest);\n});\n//# sourceMappingURL=XmlHttpRequest.js.map\n;"]}